#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import os
import sys
import locale
import textwrap
import curses
import socket
from time import sleep
from threading import Thread, Lock
from subprocess import Popen, PIPE

locale.setlocale(locale.LC_ALL, '')


def config_get_value(line):
    return line.split('=', 1)[1].strip()


def parse_config():
    # set defaults
    settings = {'lang': 'en',
                'key_quit': 'q',
                'key_toggle': 'a',
                'key_play': 'x',
                'key_pause': 'c',
                'key_next': 'b',
                'key_prev': 'z',
                'key_stop': 'v',
                'key_volup': '=',
                'key_voldn': '-'}

    try:
        config_file = os.environ['XDG_CONFIG_HOME'] + '/cmus-lyrics/rc'
    except KeyError:
        config_file = os.environ['HOME'] + '/.config/cmus-lyrics/rc'

    try:
        f = open(config_file, 'r')
    except IOError:
        pass
    else:
        for l in f.read().splitlines():
            if l.strip().startswith('#'):
                continue
            elif 'lang' in l:
                settings['lang'] = config_get_value(l)
            elif 'key_quit' in l:
                settings['key_quit'] = config_get_value(l)
            elif 'key_toggle' in l:
                settings['key_toggle'] = config_get_value(l)
            elif 'key_play' in l:
                settings['key_play'] = config_get_value(l)
            elif 'key_pause' in l:
                settings['key_pause'] = config_get_value(l)
            elif 'key_next' in l:
                settings['key_next'] = config_get_value(l)
            elif 'key_prev' in l:
                settings['key_prev'] = config_get_value(l)
            elif 'key_stop' in l:
                settings['key_stop'] = config_get_value(l)
            elif 'key_volup' in l:
                settings['key_volup'] = config_get_value(l)
            elif 'key_voldn' in l:
                settings['key_voldn'] = config_get_value(l)
        f.close()

    return settings


def safe_encode(string):
    try:
        if isinstance(string, unicode):
            string = string.encode('utf-8')
    except NameError:
        pass

    return string


def wrap(text, cols):
    wt = ''
    for l in text.splitlines():
        while len(l) > cols:
            wt += l[:cols - 2] + '->' + '\n '
            l = l[cols - 2:]
        wt += l + '\n '

    return wt[:-2]


def wrapwords(text, cols):
    wt = ''
    for l in text.split('\n'):
        for wl in textwrap.wrap(l, cols):
            wt += wl.strip() + '\n '
        wt += '\n '

    return wt.strip()


def process_socket(command, file):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(file)
    s.send(command)
    s.close()


def process_fifo(command, file):
    f = open(file, 'w')
    f.write(command)
    f.flush()


def metadata_get(type, artist, title, lang):
    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A')) or
        (type == 'artistbio' and artist == 'N/A') or
        (type == 'guitartabs' and (artist == 'N/A' or title == 'N/A'))):
        m = 'Missing tags.'
    else:
        try:
            cache_dir = os.environ['XDG_CACHE_HOME'] + '/cmus-lyrics'
        except KeyError:
            cache_dir = os.environ['HOME'] + '/.cache/cmus-lyrics'
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)

        m = Popen(['glyrc', type, '-a', artist, '-t', title,
                   '-v', '0', '-w', 'stdout', '--callback', 'cat <path>',
                   '-l', lang, '-c', cache_dir],
                  stdout=PIPE, stderr=PIPE).communicate()[0].decode('utf-8').strip()

        if m == '':
            m = 'No %s found.' % type

    return m


def get_and_update(artist, title, data):
    lyrics = metadata_get('lyrics', artist, title, data['lang'])
    artistbio = metadata_get('artistbio', artist, title, data['lang'])
    guitartabs = metadata_get('guitartabs', artist, title, data['lang'])
    data['lock'].acquire()
    try:
        if data['ui'].artist + data['ui'].title == artist + title:
            data['ui'].lyrics = lyrics
            data['ui'].artistbio = artistbio
            data['ui'].guitartabs = guitartabs
            data['ui'].update()
    finally:
        data['lock'].release()


class cmus:
    def command(self, command):
        if command == 'play':
            os.system('cmus-remote -p')
        elif command == 'pause':
            os.system('cmus-remote -u')
        elif command == 'next':
            os.system('cmus-remote -n')
        elif command == 'prev':
            os.system('cmus-remote -r')
        elif command == 'stop':
            os.system('cmus-remote -s')
        elif command == 'volup':
            os.system('cmus-remote -v +5')
        elif command == 'voldn':
            os.system('cmus-remote -v -5')

    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
            sys.exit()

        s = Popen(['cmus-remote', '-Q'],
                  stdout=PIPE, stderr=PIPE).communicate()[0].decode('utf-8')

        if 'status stopped' in s:
            self.playing = False
        else:
            self.playing = True

        if 'tag artist' in s:
            self.artist = s.split('tag artist ')[1].splitlines()[0]
        else:
            self.artist = 'N/A'

        if 'tag title' in s:
            self.title = s.split('tag title ')[1].splitlines()[0]
        else:
            self.title = 'N/A'


class shellfm:
    def command(self, command):
        socket = os.environ['HOME'] + '/.shell-fm/socket'

        if command == 'pause':
            process_socket('pause\n', socket)
        elif command == 'next':
            process_socket('skip\n', socket)
        elif command == 'stop':
            process_socket('stop\n', socket)
        elif command == 'volup':
            process_socket('volume +5\n', socket)
        elif command == 'voldn':
            process_socket('volume -5\n', socket)

    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
            sys.exit()

        try:
            np = open(os.environ['HOME'] + '/.shell-fm/nowplaying')
        except IOError:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            self.playing = True
            self.artist, self.title = np.read().split('|')
            np.close()


class pianobar:
    def __init__(self):
        try:
            self.config_dir = os.environ['XDG_CONFIG_HOME'] + '/pianobar/'
        except KeyError:
            self.config_dir = os.environ['HOME'] + '/.config/pianobar/'

        # set default keys
        self.key_pause = 'p'
        self.key_next = 'n'
        self.key_stop = 'q'
        self.key_volup = ')'
        self.key_voldn = '('

        # get keybindings from config file, in case they differ from defaults
        f = open(self.config_dir + 'config', 'r')
        for l in f.read().splitlines():
            if l.strip().startswith('#'):
                continue
            elif 'act_songpause' in l:
                self.key_pause = config_get_value(l)
            elif 'act_songnext' in l:
                self.key_next = config_get_value(l)
            elif 'act_quit' in l:
                self.key_stop = config_get_value(l)
            elif 'act_volup' in l:
                self.key_volup = config_get_value(l)
            elif 'act_voldown' in l:
                self.key_voldn = config_get_value(l)
        f.close()

    def command(self, command):
        fifo = self.config_dir + 'ctl'

        if command == 'play':
            process_fifo(self.key_pause + '\n', fifo)
        elif command == 'pause':
            process_fifo(self.key_pause + '\n', fifo)
        elif command == 'next':
            process_fifo(self.key_next + '\n', fifo)
        elif command == 'stop':
            process_fifo(self.key_stop + '\n', fifo)
        elif command == 'volup':
            process_fifo(self.key_volup + '\n', fifo)
        elif command == 'voldn':
            process_fifo(self.key_voldn + '\n', fifo)

    def status(self):
        np = self.config_dir + 'nowplaying'
        if 'pianobar' not in Popen(['ps', '-C', 'pianobar'],
                                   stdout=PIPE, stderr=PIPE).communicate()[0].decode('utf-8'):
            if os.path.exists(np):
                os.remove(np)
            sys.exit()

        try:
            f = open(np)
        except IOError:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            self.playing = True
            self.artist, self.title = f.read().split('|')
            f.close()


class mpd:
    def command(self, command):
        if command == 'play':
            os.system('mpc play > /dev/null')
        elif command == 'pause':
            os.system('mpc pause > /dev/null')
        elif command == 'next':
            os.system('mpc next > /dev/null')
        elif command == 'prev':
            os.system('mpc prev > /dev/null')
        elif command == 'stop':
            os.system('mpc stop > /dev/null')
        elif command == 'volup':
            os.system('mpc volume +5 > /dev/null')
        elif command == 'voldn':
            os.system('mpc volume -5 > /dev/null')

    def status(self):
        if 'mpd' not in Popen(['ps', '-C', 'mpd'],
                              stdout=PIPE, stderr=PIPE).communicate()[0].decode('utf-8'):
            sys.exit()

        s = Popen(['mpc', 'current', '-f', '%artist%\\%title%'],
                  stdout=PIPE, stderr=PIPE).communicate()[0].decode('utf-8')

        try:
            self.artist = s.split('\\')[0]
            if self.artist == '':
                self.artist = 'N/A'

            self.title = s.split('\\')[1].strip()
            if self.title == '':
                self.title = 'N/A'
        except IndexError:
            self.artist = 'N/A'
            self.title = 'N/A'
            self.playing = False
        else:
            self.playing = True


class moc:
    def command(self, command):
        if command == 'play':
            os.system('mocp -U 2> /dev/null')
        elif command == 'pause':
            os.system('mocp -P 2> /dev/null')
        elif command == 'next':
            os.system('mocp -f 2> /dev/null')
        elif command == 'prev':
            os.system('mocp -r 2> /dev/null')
        elif command == 'stop':
            os.system('mocp -s 2> /dev/null')
        elif command == 'volup':
            os.system('mocp --volume +5 2> /dev/null')
        elif command == 'voldn':
            os.system('mocp --volume -5 2> /dev/null')

    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.moc/pid'):
            sys.exit()

        s = Popen(['mocp', '-i'], stdout=PIPE, stderr=PIPE).communicate()[0].decode('utf-8')

        if 'State: PLAY' in s or 'State: PAUSE' in s:
            self.playing = True

            if 'Artist: \n' not in s:
                self.artist = s.split('Artist: ')[1].splitlines()[0]
            else:
                self.artist = 'N/A'

            if 'SongTitle: \n' not in s:
                self.title = s.split('SongTitle: ')[1].splitlines()[0]
            else:
                self.title = 'N/A'
        else:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'


class ui:
    def __init__(self, screen, data):
        self.quit = False
        self.screen = screen

        self.get_size()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        curses.use_default_colors()
        self.screen.keypad(1)

        self.type = 'lyrics'

        self.artist = ''
        self.title = ''
        self.lyrics = ''
        self.artistbio = ''
        self.guitartabs = ''

        self.settings = data['settings']
        self.player = data['player']

    def get_size(self):
        self.rows, self.cols = self.screen.getmaxyx()

    def update_statusbar(self):
        if self.pad_lines <= self.rows - 1:
            pos_perc = 'All'
        elif self.pos_y == 0:
            pos_perc = 'Top'
        elif self.pos_y > self.pad_lines - self.rows:
            pos_perc = 'Bot'
        else:
            pos_perc = str(int((100 / float(self.pad_lines - self.rows)) \
                               * self.pos_y - 1)) + '%'

        self.get_size()
        self.statusbar.erase()
        self.statusbar.addstr(0, self.cols - len(pos_perc) - 1, pos_perc)
        self.statusbar.refresh()

    def update(self):
        self.get_size()
        self.pos_y = 0
        if self.type == 'lyrics':
            self.header = self.artist + ' - ' + self.title
            self.text = self.lyrics
            text_wrap = wrap(self.text, self.cols - 2)
        elif self.type == 'artistbio':
            self.header = self.artist
            self.text = self.artistbio
            text_wrap = wrapwords(self.text, self.cols - 2)
        elif self.type == 'guitartabs':
            self.header = self.artist + ' - ' + self.title
            self.text = self.guitartabs
            text_wrap = wrap(self.text, self.cols - 2)
        header_wrap = wrap(self.header, self.cols - 2)
        header_wrap_lines = len(header_wrap.splitlines())
        text_wrap_lines = len(text_wrap.splitlines())
        self.pad_lines = header_wrap_lines + 1 + text_wrap_lines

        # main window
        self.pad = curses.newpad(self.pad_lines + self.rows, self.cols)
        self.pad.addstr(0, 1, safe_encode(header_wrap), curses.A_BOLD)
        self.pad.addstr(header_wrap_lines + 1, 1, safe_encode(text_wrap))
        self.pad.refresh(0, 0, 0, 0, self.rows - 2, self.cols)

        # statusbar
        self.statusbar = curses.newwin(1, self.cols, self.rows - 1, 0)
        self.statusbar.resize(1, self.cols)
        self.update_statusbar()

    def control(self):
        while True:
            key = self.screen.getch()

            if key == ord(self.settings['key_quit']):
                self.quit = True

            else:
                if key == curses.KEY_DOWN or key == ord('j'):
                    if self.pos_y < self.pad_lines - self.rows + 1:
                        self.pos_y += 1

                elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                    if self.pos_y < self.pad_lines - self.rows + 1:
                        self.pos_y += self.rows - 1

                elif key == curses.KEY_END or key == ord('G'):
                    if self.pos_y < self.pad_lines - self.rows + 1:
                        self.pos_y = self.pad_lines - self.rows + 1

                elif key == curses.KEY_UP or key == ord('k'):
                    if self.pos_y > 0:
                        self.pos_y -= 1

                elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                    if self.pos_y - self.rows > 0:
                        self.pos_y -= self.rows - 1
                    else:
                        self.pos_y = 0

                elif key == curses.KEY_HOME or key == ord('g'):
                    self.pos_y = 0

                elif key == curses.KEY_RESIZE:
                    self.update()

                elif key == ord(self.settings['key_toggle']):
                    if self.type == 'lyrics':
                        self.type = 'artistbio'
                    elif self.type == 'artistbio':
                        self.type = 'guitartabs'
                    elif self.type == 'guitartabs':
                        self.type = 'lyrics'
                    self.update()

                elif key == ord(self.settings['key_play']):
                    self.player.command('play')

                elif key == ord(self.settings['key_pause']):
                    self.player.command('pause')

                elif key == ord(self.settings['key_next']):
                    self.player.command('next')

                elif key == ord(self.settings['key_prev']):
                    self.player.command('prev')

                elif key == ord(self.settings['key_stop']):
                    self.player.command('stop')

                elif key == ord(self.settings['key_volup']):
                    self.player.command('volup')

                elif key == ord(self.settings['key_voldn']):
                    self.player.command('voldn')

                self.pad.refresh(self.pos_y, 0, 0, 0, self.rows - 2, self.cols)
                self.update_statusbar()


def main(stdscr):
    settings = parse_config()

    u = ui(stdscr, {'player': p, 'settings': settings})

    ui_control = Thread(target=u.control)
    ui_control.daemon = True
    ui_control.start()

    lock = Lock()
    data = {'ui': u, 'lock': lock, 'lang': settings['lang']}

    while True:
        if u.quit == True:
            break

        p.status()

        if p.playing == True:
            if p.artist != u.artist or p.title != u.title:
                lock.acquire()
                try:
                    u.artist = p.artist
                    u.title = p.title
                    u.lyrics = 'Downloading lyrics...'
                    u.artistbio = 'Downloading artist info...'
                    u.guitartabs = 'Downloading guitar tab...'
                    u.update()
                finally:
                    lock.release()

                worker = Thread(target=get_and_update,
                                args=(p.artist, p.title, data))
                worker.daemon = True
                worker.start()
        else:
            u.artist = p.artist
            u.title = p.title
            u.lyrics = 'Not playing'
            u.artistbio = 'Not playing'
            u.guitartabs = 'Not playing'
            u.update()

        sleep(1)


if __name__ == '__main__':
    if os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
        p = cmus()
    elif os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
        p = shellfm()
    elif 'pianobar' in os.popen('ps -C pianobar').read():
        p = pianobar()
    elif 'mpd' in os.popen('ps -C mpd').read():
        p = mpd()
    elif os.path.exists(os.environ['HOME'] + '/.moc/pid'):
        p = moc()
    else:
        print('No supported player found.')
        sys.exit()

    curses.wrapper(main)
