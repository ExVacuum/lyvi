#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import re
import os
import sys
import string
import socket
import urllib2
import locale
import curses
import curses.wrapper
from time import sleep
from threading import Thread

from BeautifulSoup import BeautifulSoup

locale.setlocale(locale.LC_ALL, '')

origGetAddrInfo = socket.getaddrinfo


def getAddrInfoWrapper(host, port, family=0, socktype=0, proto=0, flags=0):
    return origGetAddrInfo(host, port, socket.AF_INET, socktype, proto, flags)

socket.getaddrinfo = getAddrInfoWrapper


def strip_html(text):
    p = re.compile(r'<.*?>')

    return p.sub('', text)


def wrap(text, cols):
    wrapped_text = ''
    for line in text.split('\n'):
        while len(line) > cols:
            wrapped_text += line[:cols - 2] + '->' + '\n'
            line = line[cols - 2:]
        wrapped_text += line + '\n'

    return wrapped_text[:-1]


class cmus:
    def status(self):
        try:
            self.stat = os.popen('cmus-remote -Q').read()
        except IOError:
            pass
        else:
            try:
                self.artist = self.stat.split('tag artist ')[1].split('\n')[0]
                self.title = self.stat.split('tag title ')[1].split('\n')[0]
            except IndexError:
                self.artist = 'N/A'
                self.title = 'N/A'


class lyrics:
    def get(self, artist, title):
        cache_dir = os.environ['HOME'] + '/.lyrics'
        lyrics_file = '%s - %s' % (artist, title)

        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)
        cache = [file for file in os.listdir(cache_dir)]

        if lyrics_file in cache:
            f = open('%s/%s' % (cache_dir, lyrics_file), 'r')
            self.lyrics = f.read()
            f.close()
        else:
            keywords = ('%s:%s' % (artist, title)).replace(' ', '_')
            url = 'http://lyrics.wikia.com/%s' % keywords
            try:
                p = urllib2.urlopen(url)
            except urllib2.HTTPError:
                self.lyrics = 'Nothing found.'
            else:
                try:
                    s = BeautifulSoup(p.read(),
                                      convertEntities=BeautifulSoup.HTML_ENTITIES)
                except TypeError:
                    self.lyrics = 'Nothing found.'
                else:
                    self.lyrics = ''
                    try:
                        for line in str(s).split('height="17" /></a></div>')[1] \
                                    .split('<!--')[0] \
                                    .split('<br />'):
                            if 'External links' not in line:
                                self.lyrics += strip_html(string.strip(line) + '\n')
                                self.lyrics = self.lyrics.replace('â€¦', '...')
                            else:
                                self.lyrics = 'Nothing found.'
                    except IndexError:
                        self.lyrics = 'Nothing found.'

                    if self.lyrics != 'Nothing found.':
                        f = open('%s/%s' % (cache_dir, lyrics_file), 'w')
                        f.write(self.lyrics)
                        f.close()
                p.close()


class ui:
    def init(self, screen):
        self.quit = False
        self.screen = screen

        self.get_size()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        curses.use_default_colors()
        self.screen.keypad(1)

    def get_size(self):
        self.rows, self.cols = self.screen.getmaxyx()

    def update(self, header, text):
        self.header = header
        self.text = text
        self.pos_y = 0
        self.header_wrapped = wrap(header, self.cols - 1)
        self.text_wrapped = wrap(text, self.cols - 1)
        self.header_wrapped_lines = len(self.header_wrapped.split('\n'))
        self.text_wrapped_lines = len(self.text_wrapped.split('\n'))
        self.pad_lines = self.header_wrapped_lines + 1 + self.text_wrapped_lines

        self.pad = curses.newpad(self.pad_lines + self.rows, self.cols)
        self.pad.addstr(0, 0, self.header_wrapped, curses.A_BOLD)
        self.pad.addstr(self.header_wrapped_lines + 1, 0, self.text_wrapped)
        self.pad.refresh(0, 0, 0, 0, self.rows - 1, self.cols)

    def control(self):
        while True:
            key = self.screen.getch()

            if key == ord('q'):
                self.quit = True

            else:
                if key == curses.KEY_DOWN or key == ord('j'):
                    if self.pos_y < self.pad_lines - self.rows - 1:
                        self.pos_y += 1

                elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                    if self.pos_y + self.rows < self.pad_lines - 1:
                        self.pos_y += self.rows

                elif key == curses.KEY_END or key == ord('G'):
                    if self.pos_y < self.pad_lines - self.rows:
                        self.pos_y = self.pad_lines - self.rows - 1

                elif key == curses.KEY_UP or key == ord('k'):
                    if self.pos_y > 0:
                        self.pos_y -= 1

                elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                        if self.pos_y - self.rows > 0:
                            self.pos_y -= self.rows
                        else:
                            self.pos_y = 0

                elif key == curses.KEY_HOME or key == ord('g'):
                    self.pos_y = 0

                elif key == curses.KEY_RESIZE:
                    self.get_size()
                    self.update(self.header, self.text)

                self.pad.refresh(self.pos_y, 0, 0, 0, self.rows - 1, self.cols)


def main(stdscr):
    c = cmus()
    l = lyrics()
    u = ui()
    u.init(stdscr)

    ui_control = Thread(target=u.control)
    ui_control.daemon = True
    ui_control.start()

    artist_prev = ''
    title_prev = ''

    while True:
        c.status()

        if c.stat == '' or u.quit == True:
            break

        if c.artist != artist_prev or c.title != title_prev:
            l.get(c.artist, c.title)
            u.update(c.artist + ' - ' + c.title, l.lyrics)
            artist_prev = c.artist
            title_prev = c.title

        sleep(1)


if __name__ == '__main__':
    if not os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
        print 'Cmus is not running'
        sys.exit()

    curses.wrapper(main)
