#!/usr/bin/env python2
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import re
import os
import sys
import string
import socket
import urllib2
import curses
import curses.wrapper
from time import sleep
from threading import Thread

from BeautifulSoup import BeautifulSoup

origGetAddrInfo = socket.getaddrinfo


def getAddrInfoWrapper(host, port, family=0, socktype=0, proto=0, flags=0):
    return origGetAddrInfo(host, port, socket.AF_INET, socktype, proto, flags)

socket.getaddrinfo = getAddrInfoWrapper


def strip_html(text):
    p = re.compile(r'<.*?>')

    return p.sub('', text)


def wrap(text, cols):
    wrapped_text = ''
    for line in text.split('\n'):
        while len(line) > cols:
            wrapped_text += line[:cols - 2] + '->' + '\n'
            line = line[cols - 2:]
        wrapped_text += line + '\n'

    return wrapped_text + '\n'


class cmus:
    def __init__(self):
        if not os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
            print 'Cmus is not running'
            sys.exit()

    def status(self):
        try:
            self.stat = os.popen('cmus-remote -Q').read()
        except IOError:
            pass
        else:
            try:
                self.artist = self.stat.split('tag artist ')[1].split('\n')[0]
                self.title = self.stat.split('tag title ')[1].split('\n')[0]
            except IndexError:
                self.artist = 'N/A'
                self.title = 'N/A'


class lyrics:
    def get(self, artist, title):
        cache_dir = os.environ['HOME'] + '/.lyrics'
        lyrics_file = '%s - %s' % (artist, title)

        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)
        cache = [file for file in os.listdir(cache_dir)]

        if lyrics_file in cache:
            f = open('%s/%s' % (cache_dir, lyrics_file), 'r')
            self.lyrics = f.read()
            f.close()
        else:
            keywords = ('%s:%s' % (artist, title)).replace(' ', '_')
            url = 'http://lyrics.wikia.com/%s' % keywords
            try:
                p = urllib2.urlopen(url)
            except urllib2.HTTPError:
                self.lyrics = 'Nothing found.'
            else:
                s = BeautifulSoup(p.read(),
                                  convertEntities=BeautifulSoup.HTML_ENTITIES)
                p.close()
                self.lyrics = ''
                try:
                    for line in str(s).split('height="17" /></a></div>')[1] \
                                .split('<!--')[0] \
                                .split('<br />'):
                        self.lyrics += strip_html(string.strip(line) + '\n')
                except IndexError:
                    self.lyrics = 'Nothing found.'
                else:
                    f = open('%s/%s' % (cache_dir, lyrics_file), 'w')
                    f.write(self.lyrics)
                    f.close()


class ui:
    def init(self, screen):
        self.quit = False
        self.screen = screen

        self.get_size()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        curses.use_default_colors()
        self.screen.keypad(1)

    def get_size(self):
        self.rows, self.cols = self.screen.getmaxyx()

    def update(self, header, text):
        self.pos_y = 0
        self.header = wrap(header, self.cols - 1)
        self.text = wrap(text, self.cols - 1)
        self.header_lines = len(self.header.split('\n')) - 1
        self.text_lines = len(self.text.split('\n'))

        self.pad = curses.newpad(5000, self.cols)
        self.pad.addstr(0, 0, self.header, curses.A_BOLD)
        self.pad.addstr(self.header_lines, 0, self.text)
        self.pad.refresh(0, 0, 0, 0, self.rows - 1, self.cols)

    def control(self):
        while True:
            key = self.screen.getch()

            if  (key == curses.KEY_DOWN or key == ord('j')):
                if (self.pos_y < self.header_lines + self.text_lines - self.rows - 3):
                    self.pos_y += 1
                    self.pad.refresh(self.pos_y, 0,
                                     0, 0, self.rows - 1, self.cols)

            elif (key == curses.KEY_UP or key == ord('k')):
                if self.pos_y > 0:
                    self.pos_y -= 1
                    self.pad.refresh(self.pos_y, 0,
                                     0, 0, self.rows - 1, self.cols)

            elif key == ord('q'):
                self.quit = True

            elif key == curses.KEY_RESIZE:
                self.get_size()
                self.update(self.header, self.text)


def main(stdscr):
    c = cmus()
    l = lyrics()
    u = ui()
    u.init(stdscr)

    ui_control = Thread(target=u.control)
    ui_control.daemon = True
    ui_control.start()

    artist_prev = ''
    title_prev = ''

    while True:
        c.status()

        if c.stat == '' or u.quit == True:
            break

        if c.artist != artist_prev or c.title != title_prev:
            l.get(c.artist, c.title)
            u.update(c.artist + ' - ' + c.title, l.lyrics)
            artist_prev = c.artist
            title_prev = c.title

        sleep(1)


if __name__ == '__main__':
    curses.wrapper(main)
