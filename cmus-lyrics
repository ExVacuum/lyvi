#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import os
import sys
import locale
import textwrap
import curses
import curses.wrapper
from time import sleep
from threading import Thread

locale.setlocale(locale.LC_ALL, '')


def wrap(text, cols):
    wt = ''
    for l in text.split('\n'):
        while len(l) > cols:
            wt += l[:cols - 2] + '->' + '\n'
            l = l[cols - 2:]
        wt += l + '\n'

    return wt[:-1]


def wrapwords(text, cols):
    wt = ''
    for l in text.split('\n'):
        for wl in textwrap.wrap(l, cols):
            wt += wl.strip() + '\n'
        wt += '\n'

    return wt.strip()


def metadata_get(type, artist, title):
    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A')) or
        (type == 'artistbio' and artist == 'N/A')):
        m = 'Missing tags.'
    else:
        try:
            cache_dir = os.environ['XDG_CACHE_HOME'] + '/cmus-lyrics'
        except KeyError:
            cache_dir = os.environ['HOME'] + '/.cache/cmus-lyrics'
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)

        m = os.popen('glyrc %s \
                      -a "%s" \
                      -t "%s" \
                      -v 0 \
                      -w stdout \
                      --callback "cat <path>" \
                      -c %s' % (type, artist, title, cache_dir)) \
                      .read().strip()

        if m == '':
            m = 'No %s found.' % type

    return m


class cmus:
    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
            sys.exit()

        try:
            s = os.popen('cmus-remote -Q').read()
        except IOError:
            pass
        else:
            if 'status playing' in s or 'status paused' in s:
                self.playing = True
            else:
                self.playing = False

            if 'tag artist' in s:
                self.artist = s.split('tag artist ')[1].split('\n')[0]
            else:
                self.artist = 'N/A'

            if 'tag title' in s:
                self.title = s.split('tag title ')[1].split('\n')[0]
            else:
                self.title = 'N/A'


class shellfm:
    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
            sys.exit()

        try:
            f = open(os.environ['HOME'] + '/.shell-fm/nowplaying')
        except IOError:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            s = f.read()
            f.close()
            self.playing = True
            self.artist, self.title = s.split('|')


class pianobar:
    def status(self):
        try:
            np = os.environ['XDG_CONFIG_HOME'] + '/pianobar/nowplaying'
        except KeyError:
            np = os.environ['HOME'] + '/.config/pianobar/nowplaying'
        try:
            if 'pianobar' not in os.popen('ps -C pianobar').read():
                if os.path.exists(np):
                    os.remove(np)
                sys.exit()
        except IOError:
            pass

        try:
            f = open(np)
        except IOError:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            s = f.read().strip()
            f.close()
            self.playing = True
            self.artist, self.title = s.split('|')


class ui:
    def __init__(self, screen):
        self.quit = False
        self.screen = screen

        self.get_size()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        curses.use_default_colors()
        self.screen.keypad(1)

        self.type = 'lyrics'

        self.artist = ''
        self.title = ''
        self.lyrics = ''
        self.artistbio = ''

    def get_size(self):
        self.rows, self.cols = self.screen.getmaxyx()

    def update(self):
        self.pos_y = 0
        if self.type == 'lyrics':
            self.header = self.artist + ' - ' + self.title
            self.text = self.lyrics
            text_wrap = wrap(self.text, self.cols - 1)
        elif self.type == 'artistbio':
            self.header = self.artist
            self.text = self.artistbio
            text_wrap = wrapwords(self.text, self.cols - 1)
        header_wrap = wrap(self.header, self.cols - 1)
        header_wrap_lines = len(header_wrap.split('\n'))
        text_wrap_lines = len(text_wrap.split('\n'))
        self.pad_lines = header_wrap_lines + 1 + text_wrap_lines

        self.pad = curses.newpad(self.pad_lines + self.rows, self.cols)
        self.pad.addstr(0, 0, header_wrap, curses.A_BOLD)
        self.pad.addstr(header_wrap_lines + 1, 0, text_wrap)
        self.pad.refresh(0, 0, 0, 0, self.rows - 1, self.cols)

    def control(self):
        while True:
            key = self.screen.getch()

            if key == ord('q'):
                self.quit = True

            else:
                if key == curses.KEY_DOWN or key == ord('j'):
                    if self.pos_y < self.pad_lines - self.rows:
                        self.pos_y += 1

                elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                    if self.pos_y + self.rows < self.pad_lines:
                        self.pos_y += self.rows

                elif key == curses.KEY_END or key == ord('G'):
                    if self.pos_y < self.pad_lines - self.rows:
                        self.pos_y = self.pad_lines - self.rows

                elif key == curses.KEY_UP or key == ord('k'):
                    if self.pos_y > 0:
                        self.pos_y -= 1

                elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                    if self.pos_y - self.rows > 0:
                        self.pos_y -= self.rows
                    else:
                        self.pos_y = 0

                elif key == curses.KEY_HOME or key == ord('g'):
                    self.pos_y = 0

                elif key == curses.KEY_RESIZE:
                    self.get_size()
                    self.update()

                elif key == ord('a'):
                    if self.type == 'lyrics':
                        self.type = 'artistbio'
                    elif self.type == 'artistbio':
                        self.type = 'lyrics'
                    self.update()

                self.pad.refresh(self.pos_y, 0, 0, 0, self.rows - 1, self.cols)


def main(stdscr):
    if player == cmus:
        p = cmus()
    elif player == shellfm:
        p = shellfm()
    elif player == pianobar:
        p = pianobar()

    u = ui(stdscr)

    ui_control = Thread(target=u.control)
    ui_control.daemon = True
    ui_control.start()

    while True:
        if u.quit == True:
            break

        p.status()

        if p.playing == True:
            if p.artist != u.artist or p.title != u.title:
                u.artist = p.artist
                u.title = p.title
                u.lyrics = 'Downloading lyrics...'
                u.artistbio = 'Downloading artist info...'
                u.update()

                u.lyrics = metadata_get('lyrics', p.artist, p.title)
                u.artistbio = metadata_get('artistbio', p.artist, p.title)
                u.update()
        else:
            u.artist = p.artist
            u.title = p.title
            u.lyrics = 'Not playing'
            u.artistbio = 'Not playing'
            u.update()

        sleep(1)


if __name__ == '__main__':
    if os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
        player = cmus
    elif os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
        player = shellfm
    elif 'pianobar' in os.popen('ps -C pianobar').read():
        player = pianobar
    else:
        print('No supported player found.')
        sys.exit()

    curses.wrapper(main)
