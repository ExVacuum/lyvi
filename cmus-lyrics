#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import os
import sys
import locale
import textwrap
import curses
import curses.wrapper
import socket
from time import sleep
from threading import Thread, Lock

locale.setlocale(locale.LC_ALL, '')


def wrap(text, cols):
    wt = ''
    for l in text.split('\n'):
        while len(l) > cols:
            wt += l[:cols - 2] + '->' + '\n '
            l = l[cols - 2:]
        wt += l + '\n '

    return wt[:-2]


def wrapwords(text, cols):
    wt = ''
    for l in text.split('\n'):
        for wl in textwrap.wrap(l, cols):
            wt += wl.strip() + '\n '
        wt += '\n '

    return wt.strip()


def process_socket(command, file):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(file)
    s.send(command)
    s.close()


def process_fifo(command, file):
    f = open(file, 'w')
    f.write(command)
    f.flush()


def metadata_get(type, artist, title):
    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A')) or
        (type == 'artistbio' and artist == 'N/A') or
        (type == 'guitartabs' and (artist == 'N/A' or title == 'N/A'))):
        m = 'Missing tags.'
    else:
        try:
            cache_dir = os.environ['XDG_CACHE_HOME'] + '/cmus-lyrics'
        except KeyError:
            cache_dir = os.environ['HOME'] + '/.cache/cmus-lyrics'
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)

        while True:
            try:
                m = os.popen('glyrc %s \
                              -a "%s" \
                              -t "%s" \
                              -v 0 \
                              -w stdout \
                              --callback "cat <path>" \
                              -c %s' % (type, artist, title, cache_dir)) \
                              .read().strip()
                break
            except IOError:
                pass

        if m == '':
            m = 'No %s found.' % type

    return m


def get_and_update(artist, title, data):
    lyrics = metadata_get('lyrics', artist, title)
    artistbio = metadata_get('artistbio', artist, title)
    guitartabs = metadata_get('guitartabs', artist, title)
    data['lock'].acquire()
    try:
        if data['ui'].artist + data['ui'].title == artist + title:
            data['ui'].lyrics = lyrics
            data['ui'].artistbio = artistbio
            data['ui'].guitartabs = guitartabs
            data['ui'].update()
    finally:
        data['lock'].release()


class cmus:
    def command(self, command):
        if command == 'play':
            os.system('cmus-remote -p')
        elif command == 'pause':
            os.system('cmus-remote -u')
        elif command == 'next':
            os.system('cmus-remote -n')
        elif command == 'prev':
            os.system('cmus-remote -r')
        elif command == 'stop':
            os.system('cmus-remote -s')
        elif command == 'volup':
            os.system('cmus-remote -v +5')
        elif command == 'voldn':
            os.system('cmus-remote -v -5')

    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
            sys.exit()

        try:
            s = os.popen('cmus-remote -Q').read()
        except IOError:
            pass
        else:
            if 'status playing' in s or 'status paused' in s:
                self.playing = True
            else:
                self.playing = False

            if 'tag artist' in s:
                self.artist = s.split('tag artist ')[1].split('\n')[0]
            else:
                self.artist = 'N/A'

            if 'tag title' in s:
                self.title = s.split('tag title ')[1].split('\n')[0]
            else:
                self.title = 'N/A'


class shellfm:
    def command(self, command):
        socket = os.environ['HOME'] + '/.shell-fm/socket'

        if command == 'pause':
            process_socket('pause\n', socket)
        elif command == 'next':
            process_socket('skip\n', socket)
        elif command == 'stop':
            process_socket('stop\n', socket)
        elif command == 'volup':
            process_socket('volume +5\n', socket)
        elif command == 'voldn':
            process_socket('volume -5\n', socket)

    def status(self):
        if not os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
            sys.exit()

        try:
            f = open(os.environ['HOME'] + '/.shell-fm/nowplaying')
        except IOError:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            s = f.read()
            f.close()
            self.playing = True
            self.artist, self.title = s.split('|')


class pianobar:
    def __init__(self):
        try:
            self.config_dir = os.environ['XDG_CONFIG_HOME'] + '/pianobar/'
        except KeyError:
            self.config_dir = os.environ['HOME'] + '/.config/pianobar/'

        # set default keys
        self.key_pause = 'p'
        self.key_next = 'n'
        self.key_stop = 'q'
        self.key_volup = ')'
        self.key_voldn = '('

        # get keybindings from config file, in case they differ from defaults
        f = open(self.config_dir + 'config', 'r')
        for l in f.read().splitlines():
            if 'act_songpause' in l:
                self.key_pause = l.split('=')[1].strip()
            elif 'act_songnext' in l:
                self.key_next = l.split('=')[1].strip()
            elif 'act_quit' in l:
                self.key_stop = l.split('=')[1].strip()
            elif 'act_volup' in l:
                self.key_volup = l.split('=')[1].strip()
            elif 'act_voldown' in l:
                self.key_voldn = l.split('=')[1].strip()
        f.close()

    def command(self, command):
        fifo = self.config_dir + 'ctl'

        if command == 'play':
            process_fifo(self.key_pause + '\n', fifo)
        elif command == 'pause':
            process_fifo(self.key_pause + '\n', fifo)
        elif command == 'next':
            process_fifo(self.key_next + '\n', fifo)
        elif command == 'stop':
            process_fifo(self.key_stop + '\n', fifo)
        elif command == 'volup':
            process_fifo(self.key_volup + '\n', fifo)
        elif command == 'voldn':
            process_fifo(self.key_voldn + '\n', fifo)

    def status(self):
        np = self.config_dir + 'nowplaying'

        try:
            if 'pianobar' not in os.popen('ps -C pianobar').read():
                if os.path.exists(np):
                    os.remove(np)
                sys.exit()
        except IOError:
            pass

        try:
            f = open(np)
        except IOError:
            self.playing = False
            self.artist = 'N/A'
            self.title = 'N/A'
        else:
            s = f.read().strip()
            f.close()
            self.playing = True
            self.artist, self.title = s.split('|')


class mpd:
    def command(self, command):
        if command == 'play':
            os.system('mpc play > /dev/null')
        elif command == 'pause':
            os.system('mpc pause > /dev/null')
        elif command == 'next':
            os.system('mpc next > /dev/null')
        elif command == 'prev':
            os.system('mpc prev > /dev/null')
        elif command == 'stop':
            os.system('mpc stop > /dev/null')
        elif command == 'volup':
            os.system('mpc volume +5 > /dev/null')
        elif command == 'voldn':
            os.system('mpc volume -5 > /dev/null')

    def status(self):
        try:
            if 'mpd' not in os.popen('ps -C mpd').read():
                sys.exit()
        except IOError:
            pass

        try:
            s = os.popen('mpc current -f "%artist%\\%title%"').read()
        except IOError:
            pass
        else:
            try:
                self.artist = s.split('\\')[0]
                if self.artist == '':
                    self.artist = 'N/A'

                self.title = s.split('\\')[1].strip()
                if self.title == '':
                    self.title = 'N/A'
            except IndexError:
                self.artist = 'N/A'
                self.title = 'N/A'
                self.playing = False
            else:
                self.playing = True


class ui:
    def __init__(self, screen, player):
        self.quit = False
        self.screen = screen

        self.get_size()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        curses.use_default_colors()
        self.screen.keypad(1)

        self.type = 'lyrics'

        self.artist = ''
        self.title = ''
        self.lyrics = ''
        self.artistbio = ''
        self.guitartabs = ''

        self.player = player

    def get_size(self):
        self.rows, self.cols = self.screen.getmaxyx()

    def update(self):
        self.pos_y = 0
        if self.type == 'lyrics':
            self.header = self.artist + ' - ' + self.title
            self.text = self.lyrics
            text_wrap = wrap(self.text, self.cols - 2)
        elif self.type == 'artistbio':
            self.header = self.artist
            self.text = self.artistbio
            text_wrap = wrapwords(self.text, self.cols - 2)
        elif self.type == 'guitartabs':
            self.header = self.artist + ' - ' + self.title
            self.text = self.guitartabs
            text_wrap = wrap(self.text, self.cols - 2)
        header_wrap = wrap(self.header, self.cols - 2)
        header_wrap_lines = len(header_wrap.split('\n'))
        text_wrap_lines = len(text_wrap.split('\n'))
        self.pad_lines = header_wrap_lines + 1 + text_wrap_lines

        self.pad = curses.newpad(self.pad_lines + self.rows, self.cols)
        self.pad.addstr(0, 1, header_wrap, curses.A_BOLD)
        self.pad.addstr(header_wrap_lines + 1, 1, text_wrap)
        self.pad.refresh(0, 0, 0, 0, self.rows - 1, self.cols)

    def control(self):
        while True:
            key = self.screen.getch()

            if key == ord('q'):
                self.quit = True

            else:
                if key == curses.KEY_DOWN or key == ord('j'):
                    if self.pos_y < self.pad_lines - self.rows:
                        self.pos_y += 1

                elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                    if self.pos_y + self.rows < self.pad_lines:
                        self.pos_y += self.rows

                elif key == curses.KEY_END or key == ord('G'):
                    if self.pos_y < self.pad_lines - self.rows:
                        self.pos_y = self.pad_lines - self.rows

                elif key == curses.KEY_UP or key == ord('k'):
                    if self.pos_y > 0:
                        self.pos_y -= 1

                elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                    if self.pos_y - self.rows > 0:
                        self.pos_y -= self.rows
                    else:
                        self.pos_y = 0

                elif key == curses.KEY_HOME or key == ord('g'):
                    self.pos_y = 0

                elif key == curses.KEY_RESIZE:
                    self.get_size()
                    self.update()

                elif key == ord('a'):
                    if self.type == 'lyrics':
                        self.type = 'artistbio'
                    elif self.type == 'artistbio':
                        self.type = 'guitartabs'
                    elif self.type == 'guitartabs':
                        self.type = 'lyrics'
                    self.update()

                elif key == ord('z'):
                    self.player.command('prev')

                elif key == ord('x'):
                    self.player.command('play')

                elif key == ord('c'):
                    self.player.command('pause')

                elif key == ord('v'):
                    self.player.command('stop')

                elif key == ord('b'):
                    self.player.command('next')

                elif key == ord('='):
                    self.player.command('volup')

                elif key == ord('-'):
                    self.player.command('voldn')

                self.pad.refresh(self.pos_y, 0, 0, 0, self.rows - 1, self.cols)


def main(stdscr):
    u = ui(stdscr, p)

    ui_control = Thread(target=u.control)
    ui_control.daemon = True
    ui_control.start()

    lock = Lock()
    data = {'ui': u, 'lock': lock}

    while True:
        if u.quit == True:
            break

        p.status()

        if p.playing == True:
            if p.artist != u.artist or p.title != u.title:
                lock.acquire()
                try:
                    u.artist = p.artist
                    u.title = p.title
                    u.lyrics = 'Downloading lyrics...'
                    u.artistbio = 'Downloading artist info...'
                    u.guitartabs = 'Downloading guitar tab...'
                    u.update()
                finally:
                    lock.release()

                worker = Thread(target=get_and_update,
                                args=(p.artist, p.title, data))
                worker.daemon = True
                worker.start()
        else:
            u.artist = p.artist
            u.title = p.title
            u.lyrics = 'Not playing'
            u.artistbio = 'Not playing'
            u.guitartabs = 'Not playing'
            u.update()

        sleep(1)


if __name__ == '__main__':
    if os.path.exists(os.environ['HOME'] + '/.cmus/socket'):
        p = cmus()
    elif os.path.exists(os.environ['HOME'] + '/.shell-fm/session'):
        p = shellfm()
    elif 'pianobar' in os.popen('ps -C pianobar').read():
        p = pianobar()
    elif 'mpd' in os.popen('ps -C mpd').read():
        p = mpd()
    else:
        print('No supported player found.')
        sys.exit()

    curses.wrapper(main)
