#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import sys
if sys.version > '3':
    sys.exit('Lyvi doesn\'t work with Python 3.')

import argparse
import codecs
import curses
import logging
import os
import socket
import subprocess
from StringIO import StringIO
from textwrap import wrap as wrapwords
from threading import Thread, Lock
from time import sleep
from urllib2 import urlopen

import Image
import plyr

import dbus
import dbus.mainloop.glib


VERSION = '1.1.0-git'
GLYR_VERSION = plyr.version().split()[1]
HOME = os.environ['HOME']
CONFIG_HOME = os.environ['XDG_CONFIG_HOME'] if 'XDG_CONFIG_HOME' in os.environ else HOME + '/.config'
DATA_HOME = os.environ['XDG_DATA_HOME'] if 'XDG_DATA_HOME' in os.environ else HOME + '/.local/share'
MPRIS_INTERFACE_START = 'org.mpris.MediaPlayer2.'
MPRIS_INTERFACE_PLAYER = 'org.mpris.MediaPlayer2.Player'
SETTINGS = {
    'autoscroll': False,
    'autoscroll_step': 1,
    'autoscroll_time': 10,
    'bg': False,
    'bg_color': '000000',
    'bg_local': False,
    'bg_opacity': 0.15,
    'bg_tmux': False,
    'bg_tmux_backdrops_pane': None,
    'bg_tmux_backdrops_pane_offset_x': 0,
    'bg_tmux_backdrops_pane_offset_y': 0,
    'bg_tmux_backdrops_underlying': True,
    'bg_tmux_cover_pane': None,
    'bg_tmux_cover_pane_offset_x': 0,
    'bg_tmux_cover_pane_offset_y': 0,
    'bg_tmux_cover_underlying': True,
    'bg_tmux_height': 600,
    'bg_tmux_width': 1024,
    'bg_type': 'backdrops',
    'color_buttons': -1,
    'color_status': -1,
    'color_text': -1,
    'color_title': 7,
    'key_autoscroll_faster': 'p',
    'key_autoscroll_slower': 'o',
    'key_autoscroll_toggle': 'i',
    'key_bg_toggle': 's',
    'key_next': 'b',
    'key_pause': 'c',
    'key_play': 'x',
    'key_prev': 'z',
    'key_quit': 'q',
    'key_reload_view': 'r',
    'key_stop': 'v',
    'key_toggle': 'a',
    'key_ui_hide': 'h',
    'key_voldn': '-',
    'key_volup': '=',
    'lang': 'en',
    'mpd_config_file': HOME + '/.mpdconf' if os.path.exists(HOME + '/.mpdconf') else '/etc/mpd.conf',
    'mpd_host': os.environ['MPD_HOST'] if 'MPD_HOST' in os.environ else 'localhost',
    'mpd_port': os.environ['MPD_PORT'] if 'MPD_PORT' in os.environ else 6600,
    'player': None,
    'save_lyrics': False,
    'save_lyrics_format': '<filename>.lyric',
    'ui_hidden': False,
    'view': 'lyrics',
}
UI_LOCK = Lock()

CACHE_DIR = DATA_HOME + '/lyvi'
if not os.path.exists(CACHE_DIR):
    os.makedirs(CACHE_DIR)
DB = plyr.Database(CACHE_DIR)

HAS_TMUX = True if 'TMUX' in os.environ else False

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

class LoggingThread(Thread):
    def run(self):
        try:
            super(LoggingThread, self).run()
        except KeyboardInterrupt:
            sys.exit()
        except SystemExit:
            raise
        except Exception:
            if args.debug:
                logging.exception('Uncaught exception')
            raise


def parse_args():
    parser = argparse.ArgumentParser(prog='lyvi')
    parser.add_argument('command', nargs='?', help='send a command to player')
    parser.add_argument('-c', '--config-file', help='path to an alternate config file')
    parser.add_argument('-d', '--debug', help='enable debug mode', action='store_true')
    parser.add_argument('-v', '--version', help='print version information', action='store_true')
    return parser.parse_args()


def parse_config(file):
    """
    Parses given configuration file in the "key = value" form.
    Returns a "{'key': value}" dictionary.
    """
    settings = {}
    if os.path.exists(file):
        for line in open(file):
            if not line.strip().startswith('#') and '=' in line:
                key, value = line.partition('=')[::2]
                key, value = key.strip(), value.strip()
                if value == 'True':
                    value = True
                elif value == 'False':
                    value = False
                elif value == 'None':
                    value = None
                elif key != 'bg_color' and (value.isdigit() or (value.startswith('-') and value[1:].isdigit())):
                    value = int(value)
                settings[key] = value
            else:
                continue
    return settings


def search_player():
    players = {
        'cmus': Cmus,
        'shell-fm': Shellfm,
        'pianobar': Pianobar,
        'mocp': Moc,
        'mplayer': Mplayer,
        'vlc': Vlc,
        'deadbeef-main': Deadbeef,
        'mpg123': Mpg123,
        'consonance': Consonance,
    }

    # Test whether DBUS is running, and thus test whether there is MPris support
    mpris_dbus = False
    try:
        dbus.SessionBus()
        mpris_dbus = True
    except:
        pass

    # Try to find a player specified with "player" configuration option
    if SETTINGS['player']:
        if SETTINGS['player'] == 'mpd' and (running('mpd') or not mpd_local()):
            return Mpd(SETTINGS['mpd_host'], SETTINGS['mpd_port'])

        if mpris_dbus and running_mpris(SETTINGS['player']):
            return MPrisPlayer(SETTINGS['player'])

        if running(SETTINGS['player']):
            return players[SETTINGS['player']]()

    # Try to find a running MPRIS intance
    if mpris_dbus:
        for name in dbus.SessionBus().list_names():
            if name.startswith(MPRIS_INTERFACE_START):
                player = name[len(MPRIS_INTERFACE_START):]
                return MPrisPlayer(player)

    # Try to find a running player from the players-dict
    for player in players:
        if running(player):
            return players[player]()

    # Try to find MPD
    if running('mpd') or not mpd_local():
        return Mpd(SETTINGS['mpd_host'], SETTINGS['mpd_port'])


def wrap(text, width):
    wrapped = []
    for line in text.splitlines():
        while len(line) > width:
            wrapped.append(line[:width - 1] + 'â†’'.decode('utf-8'))
            line = line[width - 1:]
        wrapped.append(line)
    return wrapped


def process_socket(command, file):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(file)
    s.send((command + '\n').encode())
    s.close()


def process_fifo(command, file):
    f = open(file, 'w')
    f.write(command + '\n')
    f.flush()


def get_output(command):
    try:
        return subprocess.check_output(command, shell=True).decode('utf-8').strip()
    except subprocess.CalledProcessError:
        return ''


def running(process):
    """
    Returns True if the given process is running.
    """
    return True if process in get_output('ps -C %s' % process) else False


def running_mpris(playername):
    """
    Returns True if the given mpris-player is running. A MPRISPlayer-subclass should be passed to
    this method. The class does not have to be initialized.
    """
    try:
        bus = dbus.SessionBus()
        bus.get_object('org.mpris.MediaPlayer2.%s' % playername, '/org/mpris/MediaPlayer2')
        return True
    except:
        return False


def bg_set(file):
    if args.debug:
        logging.info('setting background => %s' % file)

    # Set urxvt background, keep aspect ratio
    if HAS_TMUX:
        os.system('printf "\ePtmux;\e\e]20;%s;100x100+50+50:op=keep-aspect\a\e\\\\"' % file)
    else:
        os.system('printf "\e]20;%s;100x100+50+50:op=keep-aspect\a"' % file)


def bg_unset():
    # Ugly, but I can't find any way to unset urxvt background.
    # So, we will create an image with the same color as terminal bg color and set it as background.
    if args.debug:
        logging.info('unsetting background => color: %s' % SETTINGS['bg_color'])

    bg = '/tmp/lyvi-%s-blank.png' % os.getpid()
    if not os.path.exists(bg):
        image = Image.new('RGB', (100, 100), '#' + SETTINGS['bg_color'])
        image.save(bg)

    # Set urxvt background, stretch
    if HAS_TMUX:
        os.system('printf "\ePtmux;\e\e]20;%s\a\e\\\\"' % bg)
    else:
        os.system('printf "\e]20;%s\a"' % bg)

def tmux_get_layout():
    class TmuxPane:
        pass
    display = get_output('tmux display -p \'#{window_layout}\'')
    lsp = get_output('tmux lsp')
    for delim in '[]{}':
        display = display.replace(delim, ',')
    layout = [TmuxPane()]
    layout[0].x, layout[0].y = [int(a) for a in display.split(',')[1].split('x')]
    display = display.split(',', 1)[1]
    chunks = display.split(',')
    for i in range(0, len(chunks) - 1):
        if 'x' in chunks[i] and 'x' not in chunks[i + 3]:
            layout.append(TmuxPane())
            layout[-1].x, layout[-1].y = [int(a) for a in chunks[i].split('x')]
            layout[-1].x_offset = int(chunks[i + 1])
            layout[-1].y_offset = int(chunks[i + 2])
    for chunk in lsp.splitlines():
        layout[lsp.splitlines().index(chunk) + 1].active = True if 'active' in chunk else False
    return layout


def glyr_query(type, file, artist, album, title, lang):
        query = plyr.Query(artist=artist, album=album, title=title, get_type=type, language=lang)
        query.useragent = 'lyvi/%s' % VERSION
        if SETTINGS['bg_local'] and type in ['backdrops', 'artistphoto', 'cover'] and file and os.path.exists(file):
            if args.debug:
                logging.info('using local bg (if present)')
            query.musictree_path = file
        else:
            query.database = DB

        # Running multiple instances of lyvi with one database can cause some problems
        while True:
            try:
                return query.commit()
            except:
                continue


def metadata_get(type, file, artist, album, title, lang):
    if album == 'N/A':
        album = ''

    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A'))
            or (type == 'cover' and (artist == 'N/A' or title == 'N/A'))
            or ((type == 'artistbio' or type == SETTINGS['bg_type']) and artist == 'N/A')
            or (type == 'guitartabs' and (artist == 'N/A' or title == 'N/A'))):
        return 'Missing tags'

    if type == 'background':
        if HAS_TMUX and SETTINGS['bg_tmux']:
            image = Image.new('RGB', (SETTINGS['bg_tmux_width'], SETTINGS['bg_tmux_height']), '#' + SETTINGS['bg_color'])
            backdrops = glyr_query('backdrops', file, artist, album, title, lang)
            cover = glyr_query('cover', file, artist, album, title, lang)

            layout = tmux_get_layout()
            x_cellpx = SETTINGS['bg_tmux_width'] / layout[0].x
            y_cellpx = SETTINGS['bg_tmux_height'] / layout[0].y

            if backdrops and SETTINGS['bg_tmux_backdrops_pane'] != None and SETTINGS['bg_type'] in ['backdrops', 'both']:
                pane = layout[SETTINGS['bg_tmux_backdrops_pane'] + 1]
                with open('/tmp/lyvi-%s-tmp' % os.getpid(), 'wb') as buf:
                    buf.write(backdrops[0].data)
                img_b = Image.open('/tmp/lyvi-%s-tmp' % os.getpid())
                img_b.thumbnail((pane.x * x_cellpx, pane.y * y_cellpx), Image.ANTIALIAS)
                if SETTINGS['bg_tmux_backdrops_underlying']:
                    layer = Image.new(img_b.mode, img_b.size, '#' + SETTINGS['bg_color'])
                    img_b = Image.blend(img_b, layer, 1 - float(SETTINGS['bg_opacity']))
                x1 = pane.x_offset * x_cellpx
                y1 = pane.y_offset * y_cellpx
                x2 = (pane.x_offset + pane.x) * x_cellpx
                y2 = (pane.y_offset + pane.y) * y_cellpx
                image.paste(img_b, (x1 + (x2 - x1) / 2 - img_b.size[0] / 2 + SETTINGS['bg_tmux_backdrops_pane_offset_x'],
                                    y1 + (y2 - y1) / 2 - img_b.size[1] / 2 + SETTINGS['bg_tmux_backdrops_pane_offset_y']))


            if cover and SETTINGS['bg_tmux_cover_pane'] != None and SETTINGS['bg_type'] in ['cover', 'both']:
                pane = layout[SETTINGS['bg_tmux_cover_pane'] + 1]
                with open('/tmp/lyvi-%s-tmp' % os.getpid(), 'wb') as buf2:
                    buf2.write(cover[0].data)
                img_c = Image.open('/tmp/lyvi-%s-tmp' % os.getpid())
                img_c.thumbnail((pane.x * x_cellpx, pane.y * y_cellpx), Image.ANTIALIAS)
                if SETTINGS['bg_tmux_cover_underlying']:
                    layer = Image.new(img_c.mode, img_c.size, '#' + SETTINGS['bg_color'])
                    img_c = Image.blend(img_c, layer, 1 - float(SETTINGS['bg_opacity']))
                x1 = pane.x_offset * x_cellpx
                y1 = pane.y_offset * y_cellpx
                x2 = (pane.x_offset + pane.x) * x_cellpx
                y2 = (pane.y_offset + pane.y) * y_cellpx
                image.paste(img_c, (x1 + (x2 - x1) / 2 - img_c.size[0] / 2 + SETTINGS['bg_tmux_cover_pane_offset_x'],
                                    y1 + (y2 - y1) / 2 - img_c.size[1] / 2 + SETTINGS['bg_tmux_cover_pane_offset_y']))

            buf = StringIO()
            image.save(buf, format="JPEG")
            img = buf.getvalue()
        else:
            background = glyr_query(SETTINGS['bg_type'], file, artist, album, title, lang)
            if background:
                with open('/tmp/lyvi-%s-tmp' % os.getpid(), 'wb') as buf:
                    buf.write(background[0].data)
                image1 = Image.open('/tmp/lyvi-%s-tmp' % os.getpid())
                layer = Image.new(image1.mode, image1.size, '#' + SETTINGS['bg_color'])
                image2 = Image.blend(image1, layer, 1 - float(SETTINGS['bg_opacity']))

                buf = StringIO()
                image2.save(buf, format="JPEG")
                img = buf.getvalue()
            else:
                img = None

        if img:
            file = '/tmp/lyvi-%s-bg-%s.jpg' % (os.getpid(), SETTINGS['bg_type'])
            with open(file, 'wb') as bg:
                bg.write(img)
            bg_set(file)
        else:
            bg_unset()

    else:
        try:
            return glyr_query(type, file, artist, album, title, lang)[0].data.decode('utf-8')
        except IndexError:
            return


def get_and_update(artist, album, title, file, needsupdate, ui):
    for type in needsupdate:
        metadata = metadata_get(type, file, artist, album, title, SETTINGS['lang'])

        UI_LOCK.acquire()
        try:
            if ui.artist + ui.title == artist + title:
                setattr(ui, type, metadata)
                ui.refresh()
        finally:
            UI_LOCK.release()

        # Optionally save lyric to a file
        if SETTINGS['save_lyrics'] and file and type == 'lyrics' and metadata and metadata != 'Missing tags':
            path, filename = file.rsplit('/', 1)
            lyric_file = '%s/%s' % (path, SETTINGS['save_lyrics_format'])
            replace_strings = {
                '<filename>': filename.rsplit('.', 1)[0],
                '<title>': title,
                '<artist>': artist,
            }
            for string in replace_strings:
                lyric_file = lyric_file.replace(string, replace_strings[string])
            if not os.path.exists(lyric_file.rsplit('/', 1)[0]):
                os.makedirs(lyric_file.rsplit('/', 1)[0])
            with codecs.open(lyric_file, 'w', 'utf-8') as file:
                file.write(metadata)


def cleanup():
    if SETTINGS['bg']:
        bg_unset()
        for file in ['/tmp/' + file for file in os.listdir('/tmp') if file.startswith('lyvi-%s' % os.getpid())]:
            os.remove(file)
    if not player.running:
        if os.path.exists(player.np['name']):
            os.remove(player.np['name'])


def mpd_local():
    """
    Returns True if MPD is running locally
    """
    return True if SETTINGS['mpd_host'] in ('localhost', '127.0.0.1') or os.path.exists(SETTINGS['mpd_host']) else False


class Player:
    def status(self):
        self.file = None
        if not self.run:
            self.running = True
        elif self.run['type'] == 'file':
            self.running = os.path.exists(self.run['name'])
        elif self.run['type'] == 'process':
            self.running = running(self.run['name'])
        elif self.run['type'] == 'mpris':
            self.running = running_mpris(self.run['name'])
        if not self.running:
            return

        if self.np['type'] == 'np_file' or self.np['type'] == 'np_command':
            if self.np['type'] == 'np_file':
                try:
                    with codecs.open(self.np['name'], 'r', 'utf-8') as file:
                        s = file.read()
                except IOError:
                    s = ''
            elif self.np['type'] == 'np_command':
                s = get_output(self.np['name'])

            self.playing = True
            s = s.strip().split('\\')
            if len(s) < 2:
                self.playing = False
            else:
                self.artist = s[0]
                self.title = s[1]
                self.album = s[2]
                if len(s) > 3:
                    self.file = s[3]

                    # MPD workaround
                    if self.__class__.__name__ == 'Mpd' and self.music_dir and not self.file.startswith('/'):
                        self.file = self.music_dir + self.file
                        if not os.path.exists(self.file):
                            self.file = None

                    # DeaDBeeF workaround
                    elif self.__class__.__name__ == 'Deadbeef' and self.title == self.file.rsplit('.', 1)[0]:
                        self.title = 'N/A'

        elif self.np['type'] == 'mpris':
            try:
                data = self.mprisdata()
            except:
                self.running = False
                return

            self.playing = not unicode(data['PlaybackStatus']) == 'Stopped'
            if self.playing:
                try:
                    self.artist = unicode(data['Metadata']['xesam:artist'][0])
                except:
                    self.artist = None
                try:
                    title = data['Metadata']['xesam:title']
                    #According to MPRIS/Xesam, title is a String, but some players seem return an array
                    self.title = unicode(title[0]) if isinstance(title, dbus.Array) else unicode(title)
                except:
                    self.title = None
                try:
                    self.album = unicode(data['Metadata']['xesam:album'])
                except:
                    self.album = None
                try:
                    self.file = unicode(data['Metadata']['xesam:url']).split('file://')[1]
                except:
                    self.file = None

        else:
            if self.np['type'] == 'command':
                s = get_output(self.np['name'])
            elif self.np['type'] == 'log':
                with open(self.np['name']) as file:
                    s = file.read().split(self.np['str']['beg'])[-1]
            elif self.np['type'] == 'url':
                while True:
                    try:
                        p = urlopen(self.np['name'])
                        break
                    except:
                        continue
                s = p.read().decode()
                p.close()

            if self.np['str']['stopped'] in s:
                self.playing = False
            else:
                self.playing = True
                self.artist = s.split(self.np['str']['artist_beg'])[1].split(self.np['str']['artist_end'])[0]\
                    if self.np['str']['artist_beg'] in s else 'N/A'
                self.album = s.split(self.np['str']['album_beg'])[1].split(self.np['str']['album_end'])[0]\
                    if self.np['str']['album_beg'] in s else 'N/A'
                self.title = s.split(self.np['str']['title_beg'])[1].split(self.np['str']['title_end'])[0]\
                    if self.np['str']['title_beg'] in s else 'N/A'

                if self.np['str']['file_beg'] in s:
                    self.file = s.split(self.np['str']['file_beg'])[1].split(self.np['str']['file_end'])[0]

        if not self.playing:
            self.artist = 'N/A'
            self.album = 'N/A'
            self.title = 'N/A'
        else:
            missing_tag = ['', 'Unknown artist', None]
            if self.artist in missing_tag:
                self.artist = 'N/A'
            if self.title in missing_tag:
                self.title = 'N/A'
            if self.album in missing_tag:
                self.album = 'N/A'

    def command(self, command):
        if command in self.ctl['commands']:
            if self.ctl['type'] == 'socket':
                process_socket(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'fifo':
                process_fifo(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'command':
                os.system(self.ctl['commands'][command])


class Cmus(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.cmus/socket',
        }
        self.np = {
            'type': 'command',
            'name': 'cmus-remote -Q',
            'str': {
                'artist_beg': 'tag artist ',
                'artist_end': '\n',
                'album_beg': 'tag album ',
                'album_end': '\n',
                'title_beg': 'tag title ',
                'title_end': '\n',
                'file_beg': 'file ',
                'file_end': '\n',
                'stopped': 'status stopped',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'cmus-remote -p',
                'pause': 'cmus-remote -u',
                'next': 'cmus-remote -n',
                'prev': 'cmus-remote -r',
                'stop': 'cmus-remote -s',
                'volup': 'cmus-remote -v +5%',
                'voldn': 'cmus-remote -v -5%',
            },
        }


class Shellfm(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.shell-fm/session',
        }
        self.np = {
            'type': 'np_file',
            'name': HOME + '/.shell-fm/nowplaying',
        }
        self.ctl = {
            'type': 'socket',
            'name': HOME + '/.shell-fm/socket',
            'commands': {
                'pause': 'pause',
                'next': 'skip',
                'stop': 'stop',
                'volup': 'volume +5',
                'voldn': 'volume -5',
            },
        }


class Pianobar(Player):
    def __init__(self):
        config_dir = CONFIG_HOME + '/pianobar/'

        # set default keys
        settings = {
            'key_pause': 'p',
            'key_next': 'n',
            'key_stop': 'q',
            'key_volup': ')',
            'key_voldn': '(',
        }
        settings.update(parse_config(config_dir + 'config'))

        self.run = {
            'type': 'process',
            'name': 'pianobar',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'fifo',
            'name': config_dir + 'ctl',
            'commands': {
                'play': settings['key_pause'],
                'pause': settings['key_pause'],
                'next': settings['key_next'],
                'stop': settings['key_stop'],
                'volup': settings['key_volup'],
                'voldn': settings['key_voldn'],
            },
        }


class Mpd(Player):
    def __init__(self, host, port):
        mpc = 'mpc -h %s -p %s' % (host, port)

        # Get a path to music directory from MPD configuration file
        self.music_dir = None
        if mpd_local() and os.path.exists(SETTINGS['mpd_config_file']):
            for line in open(SETTINGS['mpd_config_file']):
                if line.strip().startswith('music_directory'):
                    self.music_dir = line.split('"')[1]
                    if not self.music_dir.endswith('/'):
                        self.music_dir += '/'

        self.run = {
            'type': 'process',
            'name': 'mpd',
        } if mpd_local() else None
        self.np = {
            'type': 'np_command',
            'name': mpc + ' current -f "%artist%\\%title%\\%album%\\%file%"' if mpd_local()
                    else mpc + ' current -f "%artist%\\%title%\\%album%"',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': '%s play > /dev/null' % mpc,
                'pause': '%s pause > /dev/null' % mpc,
                'next': '%s next > /dev/null' % mpc,
                'prev': '%s prev > /dev/null' % mpc,
                'stop': '%s stop > /dev/null' % mpc,
                'volup': '%s volume +5 > /dev/null' % mpc,
                'voldn': '%s volume -5 > /dev/null' % mpc,
            },
        }


class Moc(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.moc/pid',
        }
        self.np = {
            'type': 'command',
            'name': 'mocp -i 2>/dev/null',
            'str': {
                'artist_beg': 'Artist: ',
                'artist_end': '\n',
                'album_beg': 'Album: ',
                'album_end': '\n',
                'title_beg': 'SongTitle: ',
                'title_end': '\n',
                'file_beg': 'File: ',
                'file_end': '\n',
                'stopped': 'State: STOP',
            }
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'mocp -U 2> /dev/null',
                'pause': 'mocp -P 2> /dev/null',
                'next': 'mocp -f 2> /dev/null',
                'prev': 'mocp -r 2> /dev/null',
                'stop': 'mocp -s 2> /dev/null',
                'volup': 'mocp --volume +5 2> /dev/null',
                'voldn': 'mocp --volume -5 2> /dev/null',
            },
        }


class Mplayer(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'mplayer',
        }
        self.np = {
            'type': 'log',
            'name': HOME + '/.mplayer/log',
            'str': {
                'beg': 'AUDIO_ID',
                'artist_beg': 'VALUE1=',
                'artist_end': '\n',
                'album_beg': 'VALUE3=',
                'album_end': '\n',
                'title_beg': 'VALUE0=',
                'title_end': '\n',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'fifo',
            'name': HOME + '/.mplayer/fifo',
            'commands': {
                'play': 'pause',
                'pause': 'pause',
                'next': 'pt_step 1',
                'prev': 'pt_step -1',
                'stop': 'stop',
                'volup': 'volume +1',
                'voldn': 'volume -1',
            },
        }


class Vlc(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': '/tmp/vlc.sock',
        }
        self.np = {
            'type': 'url',
            'name': 'http://localhost:8080/requests/status.xml',
            'str': {
                'artist_beg': 'name=\'artist\'>',
                'artist_end': '</info>',
                'album_beg': 'name=\'album\'>',
                'album_end': '</info>',
                'title_beg': 'name=\'title\'>',
                'title_end': '</info>',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '<state>stopped</state>',
            },
        }
        self.ctl = {
            'type': 'socket',
            'name': '/tmp/vlc.sock',
            'commands': {
                'play': 'pause',
                'pause': 'pause',
                'next': 'next',
                'prev': 'prev',
                'stop': 'stop',
                'volup': 'volup 1',
                'voldn': 'voldown 1',
            },
        }


class Deadbeef(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'deadbeef-main',
        }
        self.np = {
            'type': 'np_command',
            'name': 'deadbeef --nowplaying "%a%\\%t%\\%b%\\%f%" 2>/dev/null',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'deadbeef --play 2> /dev/null',
                'pause': 'deadbeef --toggle-pause 2> /dev/null',
                'next': 'deadbeef --next 2> /dev/null',
                'prev': 'deadbeef --prev 2> /dev/null',
                'stop': 'deadbeef --stop 2> /dev/null',
            },
        }


class Mpg123(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'mpg123',
        }
        self.np = {
            'type': 'log',
            'name': '/tmp/mpg123.log',
            'str': {
                'beg': 'Playing MPEG',
                'artist_beg': 'Artist: ',
                'artist_end': '\n',
                'album_beg': 'Album:  ',
                'album_end': '\n',
                'title_beg': 'Title:   ',
                'title_end': 'Artist:',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'fifo',
            'name': None,
            'commands': {
                # TODO
            },
        }


class MPrisPlayer(Player):
    """
    Class which supports all players that implement the MPRIS Interface.
    Initialize the player with the playername as argument (which can also be
    done by sub-classing the MPrisPlayer, and init the super properly).
    """
    def __init__(self, playername):
        self.run = {
            'type': 'mpris',
            'name': playername,
            'dbusloop': True
        }
        self.np = {
            'type': 'mpris',
            'name': playername
        }
        self.ctl = {
            'type': 'mpris',
            'command': {
                'play': 'Play',
                'pause': 'Pause',
                'next': 'Next',
                'prev': 'Previous',
                'stop': 'Stop'
            }
        }
        
        #Player status cache.
        self.playerstatus = {}

        # Store the interface in this object, so it does not have to reinitialized each second
        # in the main loop
        bus = dbus.SessionBus()
        playerobject = bus.get_object('org.mpris.MediaPlayer2.' + self.run['name'], '/org/mpris/MediaPlayer2')
        self.mprisplayer = dbus.Interface(playerobject, MPRIS_INTERFACE_PLAYER)
        self.mprisprops = dbus.Interface(playerobject, 'org.freedesktop.DBus.Properties')
        self.mprisprops.connect_to_signal("PropertiesChanged", self.loaddata)
        self.loaddata()
        
    def loaddata(self, *args, **kwargs):
        """
        Retrieve the player status over DBUS. Arguments are ignored, but
        *args and **kwargs enable support the dbus callback.
        """
        self.playerstatus = self.mprisprops.GetAll(MPRIS_INTERFACE_PLAYER)

    def mprisdata(self):
        """
        Returns the (cached) player status.
        """
        return self.playerstatus

    def command(self, command):
        """
        Overrides the Players method "command".
        Uses the MPRIS interface to call the appropiate object method.
        """
        try:
            if command == 'play':
                self.mprisplayer.PlayPause()
            elif command == 'pause':
                self.mprisplayer.Pause()
            elif command == 'next':
                self.mprisplayer.Next()
            elif command == 'prev':
                self.mprisplayer.Previous()
            elif command == 'stop':
                self.mprisplayer.Stop()
            elif command == 'volup':
                volume = self.playerstatus['Volume'] + 0.1
                self.mprisprops.Set(MPRIS_INTERFACE_PLAYER, 'Volume', min(volume, 1.0))
            elif command == 'voldn':
                volume = self.playerstatus['Volume'] - 0.1
                self.mprisprops.Set(MPRIS_INTERFACE_PLAYER, 'Volume', max(volume, 0.0))
        except dbus.DBusException:
            # Some players (rhythmbox) raises DBusException when attempt to
            # use "next"/"prev" command on first/last item of the playlist
            pass


class Consonance(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'consonance',
        }
        self.np = {
            'type': 'command',
            'name': 'consonance -c',
            'str': {
                'artist_beg': 'artist: ',
                'artist_end': '\n',
                'album_beg': 'album: ',
                'album_end': '\n',
                'title_beg': 'title: ',
                'title_end': '\n',
                'file_beg': 'file: ',
                'file_end': '\n',
                'stopped': 'state: Stopped',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'consonance -p',
                'pause': 'consonance -t',
                'next': 'consonance -n',
                'prev': 'consonance -r',
                'stop': 'consonance -s',
                'volup': 'consonance -i',
                'voldn': 'consonance -d',
            },
        }


class Window:
    def __init__(self, lines, cols, y, x):
        self.win = curses.newwin(lines, cols, y, x)
        self.hidden = False

    def get_size(self):
        self.height, self.width = self.win.getmaxyx()

    def show(self):
        self.hidden = False

    def hide(self):
        self.hidden = True

    def refresh(self):
        self.win.refresh()


class Pager(Window):
    def __init__(self, lines, cols, y, x):
        Window.__init__(self, lines, cols, y, x)
        self.get_size()
        self.view = [0, self.height]
        self.header = []
        self.text = []

    def scroll(self, increment):
        if not self.hidden:
            self.get_size()
            if increment == 'top':
                self.view[0] = 0
                self.view[1] = self.height
            elif increment == 'bot':
                self.view[1] = len(self.text) + len(self.header) + 1
                self.view[0] = self.view[1] - self.height if self.view[1] - self.height >= 0 else 0
            elif increment == 'npage':
                if self.view[0] + self.height < len(self.text) + len(self.header) + 1:
                    self.view[0] += self.height
                    self.view[1] += self.height
            elif increment == 'ppage':
                if self.view[0] - self.height < 0:
                    self.view[0] = 0
                    self.view[1] = self.height
                else:
                    self.view[0] -= self.height
                    self.view[1] -= self.height
            elif ((increment < 0 and self.view[0] + increment >= 0)
                    or (increment > 0 and self.view[1] < len(self.text) + len(self.header) + 1)):
                self.view[0] += increment
                self.view[1] += increment

    def refresh(self):
        self.win.erase()

        if not self.hidden:
            text = list(self.text)
            for i in range(0, len(self.header)):
                text.insert(i, self.header[i])
            text.insert(len(self.header), '')

            y = 0
            for i in range(self.view[0], self.view[1]):
                if i < len(self.header):
                    color = curses.color_pair(1) | curses.A_BOLD
                else:
                    color = curses.color_pair(2)
                try:
                    self.win.addstr(y, 1, text[i].encode('utf-8'), color)
                except IndexError:
                    break
                y += 1

        Window.refresh(self)


class Statusbar(Window):
    def __init__(self, lines, cols, y, x):
        Window.__init__(self, lines, cols, y, x)
        self.pos = 'Top'

    def refresh(self):
        self.win.erase()

        if not self.hidden:
            self.get_size()
            self.win.addstr(0, 1, '|<  >>  ||  >|', curses.color_pair(4))
            self.win.addstr(0, self.width - len(SETTINGS['view']) - 14, SETTINGS['view'], curses.color_pair(3))
            self.win.addstr(0, self.width - len(self.pos) - 1, self.pos, curses.color_pair(3))

        Window.refresh(self)


class Ui:
    def __init__(self, screen):
        self.screen = screen
        curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        curses.mouseinterval(0)
        curses.curs_set(0)
        self.get_size()
        curses.use_default_colors()
        curses.init_pair(1, int(SETTINGS['color_title']), -1)
        curses.init_pair(2, int(SETTINGS['color_text']), -1)
        curses.init_pair(3, int(SETTINGS['color_status']), -1)
        curses.init_pair(4, int(SETTINGS['color_buttons']), -1)

        self.quit = False
        self.default_opacity = float(SETTINGS['bg_opacity'])
        self.artist = self.album = self.title = self.file = self.lyrics = self.artistbio = self.guitartabs = None

        self.pager = Pager(self.height - 1, self.width, 0, 0)
        self.statusbar = Statusbar(1, self.width, self.height - 1, 0)

        self.hidden = False
        if SETTINGS['ui_hidden']:
            self.hide()

    def get_size(self):
        self.height, self.width = self.screen.getmaxyx()

    def refresh(self):
        try:
            if SETTINGS['view'] == 'lyrics':
                self.pager.header = wrap(self.artist + ' - ' + self.title, self.width - 2)
                self.pager.text = wrap(self.lyrics or 'No lyrics found', self.width - 2)
            elif SETTINGS['view'] == 'artistbio':
                self.pager.header = wrap(self.artist, self.width - 2)
                self.pager.text = wrapwords(self.artistbio or 'No artist info found', self.width - 2)
            elif SETTINGS['view'] == 'guitartabs':
                self.pager.header = wrap(self.artist + ' - ' + self.title, self.width - 2)
                self.pager.text = wrap(self.guitartabs or 'No guitar tabs found', self.width - 2)
        except TypeError:
            pass

        # calculate position
        lines = len(self.pager.text) + len(self.pager.header) + 1
        if lines <= self.height - 1:
            self.statusbar.pos = 'All'
        elif self.pager.view[0] == 0:
            self.statusbar.pos = 'Top'
        elif lines <= self.pager.view[1]:
            self.statusbar.pos = 'Bot'
        else:
            self.statusbar.pos = str(int((100 / float(lines - self.height)) * self.pager.view[0] - 1)) + '%'

        if SETTINGS['autoscroll']:
            self.statusbar.pos += ' (%ss)' % SETTINGS['autoscroll_time']

        self.pager.refresh()
        self.statusbar.refresh()

    def toggle_views(self):
        if not self.hidden:
            self.pager.scroll('top')

            views = ['lyrics', 'artistbio', 'guitartabs']
            i = views.index(SETTINGS['view']) + 1
            if i >= len(views):
                i = 0
            SETTINGS['view'] = views[i]

            self.refresh()

    def toggle_bg(self):
        if SETTINGS['bg'] and SETTINGS['bg_type'] != 'both':
            SETTINGS['bg_type'] = 'cover' if SETTINGS['bg_type'] == 'backdrops' else 'backdrops'
            metadata_get('background', self.file, self.artist, self.album, self.title, SETTINGS['lang'])

    def autoscroll(self):
        while True:
            sleep(SETTINGS['autoscroll_time'])
            if SETTINGS['autoscroll']:
                self.pager.scroll(1)
                self.refresh()

    def hide(self):
        if SETTINGS['bg']:
            if not self.hidden:
                SETTINGS['bg_opacity'] = 1
                self.pager.hide()
                self.statusbar.hide()
                self.hidden = True
            else:
                SETTINGS['bg_opacity'] = self.default_opacity
                self.pager.show()
                self.statusbar.show()
                self.hidden = False
            if self.artist or self.album or self.title:
                metadata_get('background', self.file, self.artist, self.album, self.title, SETTINGS['lang'])
            else:
                bg_unset()

    def control(self):
        commands = {
            ord(SETTINGS['key_play']): 'play',
            ord(SETTINGS['key_pause']): 'pause',
            ord(SETTINGS['key_next']): 'next',
            ord(SETTINGS['key_prev']): 'prev',
            ord(SETTINGS['key_stop']): 'stop',
            ord(SETTINGS['key_volup']): 'volup',
            ord(SETTINGS['key_voldn']): 'voldn',
        }

        while True:
            key = self.screen.getch()

            x = y = bstate = None
            if key == curses.KEY_MOUSE:
                id, x, y, z, bstate = curses.getmouse()

            if key == ord(SETTINGS['key_quit']):
                self.quit = True

            elif key == curses.KEY_RESIZE:
                self.get_size()

                self.pager.win.resize(self.height - 1, self.width)
                self.pager.view[1] = self.pager.view[0] + self.height - 1

                self.statusbar.win.resize(1, self.width)
                self.statusbar.win.mvwin(self.height - 1, 0)

            elif bstate == curses.BUTTON1_PRESSED:
                if y == self.height - 1:
                    if 1 <= x <= 2:
                        player.command('prev')
                    elif 5 <= x <= 6:
                        player.command('play')
                    elif 9 <= x <= 10:
                        player.command('pause')
                    elif 13 <= x <= 14:
                        player.command('next')
                    elif self.width - len(SETTINGS['view']) - 14 <= x and x < self.width - 14:
                        self.toggle_views()

            elif key == ord(SETTINGS['key_toggle']):
                self.toggle_views()

            elif key == ord(SETTINGS['key_bg_toggle']):
                self.toggle_bg()

            elif key == ord(SETTINGS['key_ui_hide']):
                self.hide()

            elif key == ord(SETTINGS['key_reload_view']):
                # Reload current view
                if SETTINGS['view'] == 'lyrics':
                    text = 'Searching lyrics...'
                elif SETTINGS['view'] == 'artistbio':
                    text = 'Searching artist info...'
                else:
                    text = 'Searching guitar tab...'
                setattr(self, SETTINGS['view'], text)
                self.refresh()

                DB.delete(plyr.Query(artist=self.artist,
                                     album=self.album,
                                     title=self.title,
                                     get_type=SETTINGS['view'],
                                     language=SETTINGS['lang']))

                worker = LoggingThread(target=get_and_update,
                                       args=(self.artist, self.album, self.title, self.file, [SETTINGS['view']], self))
                worker.daemon = True
                worker.start()

            elif key in commands:
                player.command(commands[key])

            elif key == curses.KEY_DOWN or key == ord('j'):
                self.pager.scroll(1)
            elif key == curses.KEY_UP or key == ord('k'):
                self.pager.scroll(-1)
            elif bstate == curses.BUTTON2_PRESSED:
                for _ in range(0, 3):
                    self.pager.scroll(1)
            elif bstate == curses.BUTTON4_PRESSED:
                for _ in range(0, 3):
                    self.pager.scroll(-1)
            elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                self.pager.scroll('npage')
            elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                self.pager.scroll('ppage')
            elif key == curses.KEY_END or key == ord('G'):
                self.pager.scroll('bot')
            elif key == curses.KEY_HOME or key == ord('g'):
                self.pager.scroll('top')

            elif key == ord(SETTINGS['key_autoscroll_toggle']):
                SETTINGS['autoscroll'] = True if not SETTINGS['autoscroll'] else False
            elif key == ord(SETTINGS['key_autoscroll_faster']):
                SETTINGS['autoscroll_time'] += SETTINGS['autoscroll_step']
            elif key == ord(SETTINGS['key_autoscroll_slower']):
                SETTINGS['autoscroll_time'] -= SETTINGS['autoscroll_step']
                if SETTINGS['autoscroll_time'] <= 1:
                    SETTINGS['autoscroll_time'] = 1

            self.refresh()


def initdbusloop():
    """
    Initializes the DBUS loop, required to enable asynchronous dbus calls.
    """
    #DBUS loop relies on the gobject mainloop.
    import gobject
    import dbus.glib
    
    gobject.threads_init()
    dbus.glib.init_threads()
    
    loop = gobject.MainLoop()
    gloop = LoggingThread(target=loop.run)
    gloop.daemon = True
    gloop.start()
    

def main(stdscr):
    ui = Ui(stdscr)

    ui_control = LoggingThread(target=ui.control)
    ui_control.daemon = True
    ui_control.start()

    auto_scroll = LoggingThread(target=ui.autoscroll)
    auto_scroll.daemon = True
    auto_scroll.start()
    
    if player.run and 'dbusloop' in player.run and player.run['dbusloop'] == True:
        initdbusloop()
    
    while True:
        player.status()

        if ui.quit or not player.running:
            cleanup()
            sys.exit(0 if player.running else 1)

        if player.playing:
            if player.artist != ui.artist or player.album != ui.album or player.title != ui.title:
                # Song has changed
                if args.debug:
                    logging.info('current song => artist: "%s" title: "%s" album: "%s" file: "%s"' %
                                 (player.artist, player.title, player.album, player.file))

                needsupdate = ['lyrics', 'guitartabs']
                if player.artist != ui.artist or player.album != ui.album:
                    needsupdate.insert(1, 'artistbio')
                    if SETTINGS['bg']:
                        needsupdate.insert(0, 'background')
                elif ui.artistbio == 'Searching artist info...':
                        needsupdate.insert(1, 'artistbio')
                if SETTINGS['view'] in needsupdate:
                    needsupdate.insert(1 if 'background' in needsupdate else 0,
                                       needsupdate.pop(needsupdate.index(SETTINGS['view'])))

                UI_LOCK.acquire()
                try:
                    ui.artist = player.artist
                    ui.album = player.album
                    ui.title = player.title
                    ui.file = player.file
                    if 'lyrics' in needsupdate:
                        ui.lyrics = 'Searching lyrics...'
                    if 'artistbio' in needsupdate:
                        ui.artistbio = 'Searching artist info...'
                    if 'guitartabs' in needsupdate:
                        ui.guitartabs = 'Searching guitar tab...'
                    ui.pager.scroll('top')
                    ui.refresh()
                finally:
                    UI_LOCK.release()

                worker = LoggingThread(target=get_and_update,
                                       args=(player.artist, player.album, player.title, player.file, needsupdate, ui))
                worker.daemon = True
                worker.start()
        else:
            if SETTINGS['bg']:
                bg_unset()
            ui.artist = player.artist
            ui.album = player.album
            ui.title = player.title
            ui.file = player.file
            ui.lyrics = 'Not playing'
            ui.artistbio = 'Not playing'
            ui.guitartabs = 'Not playing'
            ui.refresh()

        sleep(1)


if __name__ == '__main__':
    args = parse_args()

    # Load configuration file
    if args.config_file:
        if os.path.exists(args.config_file):
            SETTINGS.update(parse_config(args.config_file))
        else:
            sys.exit('File not found: %s' % args.config_file)
    else:
        SETTINGS.update(parse_config(CONFIG_HOME + '/lyvi/lyvi.conf'))

    if args.debug:
        logging.basicConfig(filename='lyvi.log', level=logging.DEBUG)
        logging.info('Lyvi %s (libglyr %s), executed with Python %s' % (VERSION, GLYR_VERSION, sys.version.split()[0]))
        logging.info('settings => %s', SETTINGS)

    if args.version:
        print('Lyvi %s (libglyr %s)' % (VERSION, GLYR_VERSION))
        sys.exit()

    try:
        player = search_player() or sys.exit('No supported player found.\nYou must launch your player first.')
        if args.debug:
            logging.info('player => %s' % player.__class__.__name__)

        if args.command:
            # Send a command to player
            if args.command in player.ctl['commands']:
                if args.debug:
                    logging.info('sending command => %s' % args.command)
                player.command(args.command)
            else:
                sys.exit('Unknown command: %s' % args.command)
        else:
            # Start UI
            curses.wrapper(main)
    except KeyboardInterrupt:
        sys.exit()
    except SystemExit:
        raise
    except Exception:
        if args.debug:
            logging.exception('Uncaught exception')
        raise
