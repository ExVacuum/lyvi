#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import sys
if sys.version > '3':
    sys.exit('Lyvi doesn\'t work with Python 3.')

import argparse
import codecs
import curses
import logging
import os
import socket
import subprocess
from getpass import getuser
from textwrap import wrap as wrapwords
from threading import Thread, Lock
from time import sleep
from urllib2 import urlopen

import Image
import dbus
import plyr


VERSION = '1.1.0-git'
GLYR_VERSION = plyr.version().split()[1]
HOME = os.environ['HOME']
CFG_HOME = os.environ['XDG_CONFIG_HOME'] if 'XDG_CONFIG_HOME' in os.environ else HOME + '/.config'
DATA_HOME = os.environ['XDG_DATA_HOME'] if 'XDG_DATA_HOME' in os.environ else HOME + '/.local/share'
SETTINGS = {
    'autoscroll': False,
    'autoscroll_time': 10,
    'autoscroll_step': 1,
    'bg': False,
    'bg_color': '000000',
    'bg_opacity': 0.15,
    'bg_local': False,
    'bg_type': 'backdrops',
    'color_buttons': -1,
    'color_status': -1,
    'color_text': -1,
    'color_title': 7,
    'key_autoscroll_faster': 'p',
    'key_autoscroll_slower': 'o',
    'key_autoscroll_toggle': 'i',
    'key_bg_toggle': 's',
    'key_next': 'b',
    'key_pause': 'c',
    'key_play': 'x',
    'key_prev': 'z',
    'key_quit': 'q',
    'key_stop': 'v',
    'key_toggle': 'a',
    'key_ui_hide': 'h',
    'key_voldn': '-',
    'key_volup': '=',
    'lang': 'en',
    'mpd_config_file': HOME + '/.mpdconf',
    'mpd_host': 'localhost',
    'mpd_port': 6600,
    'player': None,
    'save_lyrics': False,
    'save_lyrics_format': '<filename>.lyric',
    'ui_hidden': False,
    'view': 'lyrics',
}


class LoggingThread(Thread):
    def run(self):
        try:
            super(LoggingThread, self).run()
        except KeyboardInterrupt:
            sys.exit()
        except SystemExit:
            raise
        except Exception:
            if args.debug:
                logging.exception('Uncaught exception')
            raise


def parse_args():
    parser = argparse.ArgumentParser(prog='lyvi')
    parser.add_argument('command', nargs='?', help='send a command to player')
    parser.add_argument('-c', '--config-file', help='path to an alternate config file')
    parser.add_argument('-d', '--debug', help='enable debug mode', action='store_true')
    parser.add_argument('-v', '--version', help='print version information', action='store_true')
    return parser.parse_args()


def parse_config(file):
    settings = {}
    try:
        with open(file, 'r') as file:
            for line in file.read().splitlines():
                if not line.strip().startswith('#') and '=' in line:
                    key, value = [x.strip() for x in line.split('=', 1)]
                    if value == 'True':
                        value = True
                    elif value == 'False':
                        value = False
                    elif key != 'bg_color' and (value.isdigit() or (value.startswith('-') and value[1:].isdigit())):
                        value = int(value)
                    settings[key] = value
                else:
                    continue
    finally:
        return settings


def search_player():
    local = ('localhost', '127.0.0.1')
    players = {
        'cmus': Cmus,
        'shell-fm': Shellfm,
        'pianobar': Pianobar,
        'mocp': Moc,
        'gmusicbrowser': Gmusicbrowser,
        'mplayer': Mplayer,
        'vlc': Vlc,
        'audacious': Audacious,
        'deadbeef-main': Deadbeef,
        'qmmp': Qmmp,
        'guayadeque': Guayadeque,
        'mpg123': Mpg123,
    }
    mpris_players = (
        'spotify',
        'pymp',
    )

    if SETTINGS['player']:
        if SETTINGS['player'] == 'mpd' and (running('mpd') or SETTINGS['mpd_host'] not in local):
            return Mpd(SETTINGS['mpd_host'], SETTINGS['mpd_port'])

        try:    # DBUS and not having X11 running can cause some troubles
            if running_mpris(SETTINGS['player']):
                return MPrisPlayer(SETTINGS['player'])
        except:
            pass

        if running(SETTINGS['player']):
            return players[SETTINGS['player']]()

    for player in mpris_players:
        if running_mpris(player):
            return MPrisPlayer(player)

    for player in players:
        if running(player):
            return players[player]()

    if running('mpd') or SETTINGS['mpd_host'] not in local:
        return Mpd(SETTINGS['mpd_host'], SETTINGS['mpd_port'])


def wrap(text, width):
    wrapped = []
    for line in text.splitlines():
        while len(line) > width:
            wrapped.append(line[:width - 1] + 'â†’'.decode('utf-8'))
            line = line[width - 1:]
        wrapped.append(line)
    return wrapped


def process_socket(command, file):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(file)
    s.send((command + '\n').encode())
    s.close()


def process_fifo(command, file):
    f = open(file, 'w')
    f.write(command + '\n')
    f.flush()


def get_output(command):
    try:
        return subprocess.check_output(command, shell=True).decode('utf-8').strip()
    except subprocess.CalledProcessError:
        return ''


def running(process):
    return True if process in get_output('ps -C %s' % process) else False


def running_mpris(playername):
    """
    Returns True if the given mpris-player is running. A MPRISPlayer-subclass should be passed to
    this method. The class does not have to be initialized.
    """
    try:
        bus = dbus.SessionBus()
        bus.get_object('org.mpris.MediaPlayer2.%s' % playername, '/org/mpris/MediaPlayer2')
        return True
    except:
        return False


def bg_set(file, brightness):
    if args.debug:
        logging.info('setting background => file: "%s" brightness: "%s"' % (file, brightness))

    # set brightness
    image1 = Image.open(file)
    image2 = image1.point(lambda p: p * brightness)
    image2.save(file)

    # set urxvt background, keep aspect ratio
    os.system('printf "\e]20;%s;100x100+50+50:op=keep-aspect\a"' % file)


def bg_unset():
    # Ugly, but I can't find any way to unset urxvt background.
    # So, we will create an image with the same color as terminal bg color and set it as background.
    if args.debug:
        logging.info('unsetting background => color: %s' % SETTINGS['bg_color'])

    bg = '/tmp/lyvi-%s-blank.png' % os.getpid()
    if not os.path.exists(bg):
        image = Image.new('RGB', (100, 100), '#' + SETTINGS['bg_color'])
        image.save(bg)

    # set urxvt background, stretch
    os.system('printf "\e]20;%s\a"' % bg)


def glyr_query(type, file, artist, album, title, lang):
        query = plyr.Query(artist=artist, album=album, title=title, get_type=type, language=lang)
        query.useragent = 'lyvi/%s' % VERSION
        if SETTINGS['bg_local'] and type in ['backdrops', 'artistphoto', 'cover'] and file:
            if args.debug:
                logging.info('using local bg (if present)')
            query.musictree_path = file
        else:
            cache_dir = DATA_HOME + '/lyvi'
            if not os.path.exists(cache_dir):
                os.makedirs(cache_dir)
            db = plyr.Database(cache_dir)
            query.database = db
        return query.commit()


def metadata_get(type, file, artist, album, title, lang):
    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A'))
            or (type == 'cover' and (artist == 'N/A' or title == 'N/A'))
            or ((type == 'artistbio' or type == SETTINGS['bg_type']) and artist == 'N/A')
            or (type == 'guitartabs' and (artist == 'N/A' or title == 'N/A'))):
        return 'Missing tags'

    if type == SETTINGS['bg_type']:
        try:
            img = glyr_query(type, file, artist, album, title, lang)[0].data
        except IndexError:
            img = None
        if img:
            file = '/tmp/lyvi-%s-%s.jpg' % (os.getpid(), SETTINGS['bg_type'])
            with open(file, 'wb') as bg:
                bg.write(img)
            bg_set(file, float(SETTINGS['bg_opacity']))
        else:
            bg_unset()

    else:
        try:
            return glyr_query(type, file, artist, album, title, lang)[0].data.decode('utf-8')
        except IndexError:
            return


def get_and_update(artist, album, title, file, needsupdate, ui, lock):
    for type in needsupdate:
        metadata = metadata_get(type, file, artist, album, title, SETTINGS['lang'])

        lock.acquire()
        try:
            if ui.artist + ui.title == artist + title:
                setattr(ui, type, metadata)
                ui.refresh()
        finally:
            lock.release()

        # Optionally save lyric to a file
        if SETTINGS['save_lyrics'] and file and type == 'lyrics' and metadata and metadata != 'Missing tags':
            path, filename = file.rsplit('/', 1)
            lyric_file = '%s/%s' % (path, SETTINGS['save_lyrics_format'])
            replace_strings = {
                '<filename>': filename.rsplit('.', 1)[0],
                '<title>': title,
                '<artist>': artist,
            }
            for string in replace_strings:
                lyric_file = lyric_file.replace(string, replace_strings[string])
            if not os.path.exists(lyric_file.rsplit('/', 1)[0]):
                os.makedirs(lyric_file.rsplit('/', 1)[0])
            with codecs.open(lyric_file, 'w', 'utf-8') as file:
                file.write(metadata)


def cleanup():
    if SETTINGS['bg']:
        bg_unset()
        for file in ['/tmp/' + file for file in os.listdir('/tmp') if file.startswith('lyvi-%s' % os.getpid())]:
            os.remove(file)
    if not player.running:
        if os.path.exists(player.np['name']):
            os.remove(player.np['name'])


class Player:
    def status(self):
        self.file = None
        if not self.run:
            self.running = True
        elif self.run['type'] == 'file':
            self.running = os.path.exists(self.run['name'])
        elif self.run['type'] == 'process':
            self.running = running(self.run['name'])
        elif self.run['type'] == 'mpris':
            self.running = running_mpris(self.run['name'])

        if self.np['type'] == 'np_file' or self.np['type'] == 'np_command':
            if self.np['type'] == 'np_file':
                try:
                    with codecs.open(self.np['name'], 'r', 'utf-8') as file:
                        s = file.read()
                except IOError:
                    s = ''
            elif self.np['type'] == 'np_command':
                s = get_output(self.np['name'])

            self.playing = True
            s = s.strip().split('\\')
            if len(s) < 2:
                self.playing = False
            else:
                self.artist = s[0]
                self.title = s[1]
                self.album = s[2]
                if len(s) > 3:
                    self.file = s[3]

                    # mpd workaround
                    if self.__class__.__name__ == 'Mpd':
                        f = open(SETTINGS['mpd_config_file'])
                        for line in f.read().splitlines():
                            if 'music_directory' in line and '#' not in line.split('music_directory')[0]:
                                music_dir = line.split('"')[1]
                        if not music_dir.endswith('/'):
                            music_dir += '/'
                        self.file = music_dir + self.file

                    # deadbeef workaround
                    if self.title == self.file.rsplit('.', 1)[0]:
                        self.title = 'N/A'

        elif self.np['type'] == 'mpris' and self.running:
            data = self._mprisdata()

            self.playing = not str(data['PlaybackStatus']) == 'Stopped'
            if self.playing:
                try:
                    self.artist = str(data['Metadata']['xesam:artist'][0])
                except:
                    self.artist = None
                try:
                    self.title = str(data['Metadata']['xesam:title'])
                except:
                    self.title = None
                try:
                    self.album = str(data['Metadata']['xesam:album'])
                except:
                    self.album = None

        else:
            if self.np['type'] == 'command':
                s = get_output(self.np['name'])
            elif self.np['type'] == 'log':
                with open(self.np['name']) as file:
                    s = file.read().split(self.np['str']['beg'])[-1]
            elif self.np['type'] == 'url':
                while True:
                    try:
                        p = urlopen(self.np['name'])
                        break
                    except:
                        continue
                s = p.read().decode()
                p.close()

            if self.np['str']['stopped'] in s:
                self.playing = False
            else:
                self.playing = True
                self.artist = s.split(self.np['str']['artist_beg'])[1].split(self.np['str']['artist_end'])[0]\
                    if self.np['str']['artist_beg'] in s else 'N/A'
                self.album = s.split(self.np['str']['album_beg'])[1].split(self.np['str']['album_end'])[0]\
                    if self.np['str']['album_beg'] in s else 'N/A'
                self.title = s.split(self.np['str']['title_beg'])[1].split(self.np['str']['title_end'])[0]\
                    if self.np['str']['title_beg'] in s else 'N/A'

                if self.np['str']['file_beg'] in s:
                    self.file = s.split(self.np['str']['file_beg'])[1].split(self.np['str']['file_end'])[0]

                    # guayadeque workaround
                    if self.__class__.__name__ == 'Guayadeque':
                        if self.file.startswith('file://'):
                            self.file = self.file.split('file://')[1]
                        else:
                            self.file = None

        if not self.playing:
            self.artist = 'N/A'
            self.album = 'N/A'
            self.title = 'N/A'
        else:
            missing_tag = ['', 'Unknown artist', None]
            if self.artist in missing_tag:
                self.artist = 'N/A'
            if self.title in missing_tag:
                self.title = 'N/A'

    def command(self, command):
        if command in self.ctl['commands']:
            if self.ctl['type'] == 'socket':
                process_socket(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'fifo':
                process_fifo(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'command':
                os.system(self.ctl['commands'][command])


class Cmus(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.cmus/socket',
        }
        self.np = {
            'type': 'command',
            'name': 'cmus-remote -Q',
            'str': {
                'artist_beg': 'tag artist ',
                'artist_end': '\n',
                'album_beg': 'tag album ',
                'album_end': '\n',
                'title_beg': 'tag title ',
                'title_end': '\n',
                'file_beg': 'file ',
                'file_end': '\n',
                'stopped': 'status stopped',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'cmus-remote -p',
                'pause': 'cmus-remote -u',
                'next': 'cmus-remote -n',
                'prev': 'cmus-remote -r',
                'stop': 'cmus-remote -s',
                'volup': 'cmus-remote -v +5%',
                'voldn': 'cmus-remote -v -5%',
            },
        }


class Shellfm(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.shell-fm/session',
        }
        self.np = {
            'type': 'np_file',
            'name': HOME + '/.shell-fm/nowplaying',
        }
        self.ctl = {
            'type': 'socket',
            'name': HOME + '/.shell-fm/socket',
            'commands': {
                'pause': 'pause',
                'next': 'skip',
                'stop': 'stop',
                'volup': 'volume +5',
                'voldn': 'volume -5',
            },
        }


class Pianobar(Player):
    def __init__(self):
        config_dir = CFG_HOME + '/pianobar/'

        # set default keys
        settings = {
            'key_pause': 'p',
            'key_next': 'n',
            'key_stop': 'q',
            'key_volup': ')',
            'key_voldn': '(',
        }
        settings.update(parse_config(config_dir + 'config'))

        self.run = {
            'type': 'process',
            'name': 'pianobar',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'fifo',
            'name': config_dir + 'ctl',
            'commands': {
                'play': settings['key_pause'],
                'pause': settings['key_pause'],
                'next': settings['key_next'],
                'stop': settings['key_stop'],
                'volup': settings['key_volup'],
                'voldn': settings['key_voldn'],
            },
        }


class Mpd(Player):
    def __init__(self, host, port):
        local = ('localhost', '127.0.0.1')
        mpc = 'mpc -h %s -p %s' % (host, port)

        self.run = {
            'type': 'process',
            'name': 'mpd',
        } if host in local else None
        self.np = {
            'type': 'np_command',
            'name': mpc + ' current -f "%artist%\\%title%\\%album%\\%file%"' if host in local or os.path.exists(host)
            else mpc + ' current -f "%artist%\\%title%\\%album%"',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': '%s play > /dev/null' % mpc,
                'pause': '%s pause > /dev/null' % mpc,
                'next': '%s next > /dev/null' % mpc,
                'prev': '%s prev > /dev/null' % mpc,
                'stop': '%s stop > /dev/null' % mpc,
                'volup': '%s volume +5 > /dev/null' % mpc,
                'voldn': '%s volume -5 > /dev/null' % mpc,
            },
        }


class Moc(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.moc/pid',
        }
        self.np = {
            'type': 'command',
            'name': 'mocp -i 2>/dev/null',
            'str': {
                'artist_beg': 'Artist: ',
                'artist_end': '\n',
                'album_beg': 'Album: ',
                'album_end': '\n',
                'title_beg': 'SongTitle: ',
                'title_end': '\n',
                'file_beg': 'File: ',
                'file_end': '\n',
                'stopped': 'State: STOP',
            }
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'mocp -U 2> /dev/null',
                'pause': 'mocp -P 2> /dev/null',
                'next': 'mocp -f 2> /dev/null',
                'prev': 'mocp -r 2> /dev/null',
                'stop': 'mocp -s 2> /dev/null',
                'volup': 'mocp --volume +5 2> /dev/null',
                'voldn': 'mocp --volume -5 2> /dev/null',
            },
        }


class Mplayer(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'mplayer',
        }
        self.np = {
            'type': 'log',
            'name': HOME + '/.mplayer/log',
            'str': {
                'beg': 'AUDIO_ID',
                'artist_beg': 'VALUE1=',
                'artist_end': '\n',
                'album_beg': 'VALUE3=',
                'album_end': '\n',
                'title_beg': 'VALUE0=',
                'title_end': '\n',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'fifo',
            'name': HOME + '/.mplayer/fifo',
            'commands': {
                'play': 'pause',
                'pause': 'pause',
                'next': 'pt_step 1',
                'prev': 'pt_step -1',
                'stop': 'stop',
                'volup': 'volume +1',
                'voldn': 'volume -1',
            },
        }


class Vlc(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': '/tmp/vlc.sock',
        }
        self.np = {
            'type': 'url',
            'name': 'http://localhost:8080/requests/status.xml',
            'str': {
                'artist_beg': 'name=\'artist\'>',
                'artist_end': '</info>',
                'album_beg': 'name=\'album\'>',
                'album_end': '</info>',
                'title_beg': 'name=\'title\'>',
                'title_end': '</info>',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '<state>stopped</state>',
            },
        }
        self.ctl = {
            'type': 'socket',
            'name': '/tmp/vlc.sock',
            'commands': {
                'play': 'pause',
                'pause': 'pause',
                'next': 'next',
                'prev': 'prev',
                'stop': 'stop',
                'volup': 'volup 1',
                'voldn': 'voldown 1',
            },
        }


class Audacious(Player):
    def __init__(self):
        config_dir = CFG_HOME + '/audacious/'

        self.run = {
            'type': 'file',
            'name': config_dir + 'lock',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'audtool --playback-playpause',
                'pause': 'audtool --playback-playpause',
                'next': 'audtool --playlist-advance',
                'prev': 'audtool --playlist-reverse',
                'stop': 'audtool --playback-stop',
                'volup': 'audtool --set-volume +5',
                'voldn': 'audtool --set-volume -5',
            },
        }


class Deadbeef(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'deadbeef-main',
        }
        self.np = {
            'type': 'np_command',
            'name': 'deadbeef --nowplaying "%a%\\%t%\\%b%\\%f%" 2>/dev/null',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'deadbeef --play 2> /dev/null',
                'pause': 'deadbeef --toggle-pause 2> /dev/null',
                'next': 'deadbeef --next 2> /dev/null',
                'prev': 'deadbeef --prev 2> /dev/null',
                'stop': 'deadbeef --stop 2> /dev/null',
            },
        }


class Qmmp(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': '/tmp/qmmp.sock.1000',
        }
        self.np = {
            'type': 'command',
            'name': 'qmmp --status --no-start',
            'str': {
                'artist_beg': 'ARTIST = ',
                'artist_end': '\n',
                'album_beg': 'ALBUM = ',
                'album_end': '\n',
                'title_beg': 'TITLE = ',
                'title_end': '\n',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '[stopped]',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'qmmp -t',
                'pause': 'qmmp -t',
                'next': 'qmmp --next',
                'prev': 'qmmp --previous',
                'stop': 'qmmp -s',
                'volup': 'qmmp --volume-inc',
                'voldn': 'qmmp --volume-dec',
            },
        }


class Guayadeque(Player):
    def __init__(self):
        cmd_base = 'dbus-send --print-reply --type=method_call --dest=org.mpris.guayadeque /Player\
                    org.freedesktop.MediaPlayer.'
        str_base = '"\n         variant             string "'

        self.run = {
            'type': 'file',
            'name': '%s/.guayadeque/.guayadeque-%s' (HOME, getuser()),
        }
        self.np = {
            'type': 'command',
            'name': cmd_base + 'GetMetadata',
            'str': {
                'artist_beg': 'artist' + str_base,
                'artist_end': '"\n',
                'album_beg': 'album' + str_base,
                'album_end': '"\n',
                'title_beg': 'title' + str_base,
                'title_end': '"\n',
                'file_beg': 'location' + str_base,
                'file_end': '"\n',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': cmd_base + 'Play &> /dev/null',
                'pause': cmd_base + 'Play &> /dev/null',
                'next': cmd_base + 'Next &> /dev/null',
                'prev': cmd_base + 'Prev &> /dev/null',
                'stop': cmd_base + 'Stop &> /dev/null',
            },
        }


class Gmusicbrowser(Player):
    def __init__(self):
        config_dir = CFG_HOME + '/gmusicbrowser/'

        self.run = {
            'type': 'file',
            'name': config_dir + 'gmusicbrowser.fifo',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'fifo',
            'name': self.run['name'],
            'commands': {
                'play': 'PlayPause',
                'pause': 'PlayPause',
                'next': 'NextSong',
                'prev': 'PrevSong',
                'stop': 'Stop',
            },
        }


class Mpg123(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'mpg123',
        }
        self.np = {
            'type': 'log',
            'name': '/tmp/mpg123.log',
            'str': {
                'beg': 'Playing MPEG',
                'artist_beg': 'Artist: ',
                'artist_end': '\n',
                'album_beg': 'Album:  ',
                'album_end': '\n',
                'title_beg': 'Title:   ',
                'title_end': 'Artist:',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'fifo',
            'name': None,
            'commands': {
                # TODO
            },
        }


class MPrisPlayer(Player):
    """
    Class which supports all players that implement the MPRIS Media.
    Initialize the player with the playername as argument (which
    of course can also be done with sub-classing and calling the super with a
    pre-defined playername.
    """
    def __init__(self, playername):
        self.run = {
            'type': 'mpris',
            'name': playername
        }
        self.np = {'type': 'mpris'}
        self.ctl = {
            'type': 'mpris',
            'command': {
                'play': 'Play',
                'pause': 'Pause',
                'next': 'Next',
                'prev': 'Previous',
                'stop': 'Stop'
            }
        }

        # Store the interface in this object, so it does not have to reinitialized each second
        # in the main loop
        bus = dbus.SessionBus()
        self.mprisplayer = bus.get_object('org.mpris.MediaPlayer2.' + self.run['name'], '/org/mpris/MediaPlayer2')
        self.mprisplayerif = dbus.Interface(self.mprisplayer, 'org.freedesktop.DBus.Properties')

    def _mprisdata(self):
        # Future improvement can be: cache and connect to the propertiesChanged signal.
        return self.mprisplayerif.GetAll('')

    def command(self, command):
        '''
        Overrides the Players method "command".
        Uses the MPRIS interface to call the appropiate object method.
        '''
        if command == 'play':
            self.mprisplayer.PlayPause()
        elif command == 'pause':
            self.mprisplayer.Pause()
        elif command == 'next':
            self.mprisplayer.Next()
        elif command == 'prev':
            self.mprisplayer.Previous()
        elif command == 'stop':
            self.mprisplayer.Stop()
        elif command == 'volup':
            pass    # Can be implemented by getting the volume value, and then update it with +0.1
        elif command == 'voldown':
            pass    # Can be implemented by getting the volume value, and then update it with -0.1
        else:
            pass


class Window:
    def __init__(self, lines, cols, y, x):
        self.win = curses.newwin(lines, cols, y, x)
        self.hidden = False

    def get_size(self):
        self.height, self.width = self.win.getmaxyx()

    def show(self):
        self.hidden = False

    def hide(self):
        self.hidden = True

    def refresh(self):
        self.win.refresh()


class Pager(Window):
    def __init__(self, lines, cols, y, x):
        Window.__init__(self, lines, cols, y, x)
        self.get_size()
        self.view = [0, self.height]
        self.header = []
        self.text = []

    def scroll(self, increment):
        if not self.hidden:
            self.get_size()
            if increment == 'top':
                self.view[0] = 0
                self.view[1] = self.height
            elif increment == 'bot':
                self.view[1] = len(self.text) + len(self.header) + 1
                self.view[0] = self.view[1] - self.height if self.view[1] - self.height >= 0 else 0
            elif increment == 'npage':
                if self.view[0] + self.height < len(self.text) + len(self.header) + 1:
                    self.view[0] += self.height
                    self.view[1] += self.height
            elif increment == 'ppage':
                if self.view[0] - self.height < 0:
                    self.view[0] = 0
                    self.view[1] = self.height
                else:
                    self.view[0] -= self.height
                    self.view[1] -= self.height
            elif ((increment < 0 and self.view[0] + increment >= 0)
                    or (increment > 0 and self.view[1] < len(self.text) + len(self.header) + 1)):
                self.view[0] += increment
                self.view[1] += increment

    def refresh(self):
        self.win.erase()

        if not self.hidden:
            text = list(self.text)
            for i in range(0, len(self.header)):
                text.insert(i, self.header[i])
            text.insert(len(self.header), '')

            y = 0
            for i in range(self.view[0], self.view[1]):
                if i < len(self.header):
                    color = curses.color_pair(1) | curses.A_BOLD
                else:
                    color = curses.color_pair(2)
                try:
                    self.win.addstr(y, 1, text[i].encode('utf-8'), color)
                except IndexError:
                    break
                y += 1

        Window.refresh(self)


class Statusbar(Window):
    def __init__(self, lines, cols, y, x):
        Window.__init__(self, lines, cols, y, x)
        self.pos = 'Top'

    def refresh(self):
        self.win.erase()

        if not self.hidden:
            self.get_size()
            self.win.addstr(0, 1, '|<  >>  ||  >|', curses.color_pair(4))
            self.win.addstr(0, self.width - len(SETTINGS['view']) - 14, SETTINGS['view'], curses.color_pair(3))
            self.win.addstr(0, self.width - len(self.pos) - 1, self.pos, curses.color_pair(3))

        Window.refresh(self)


class Ui:
    def __init__(self, screen):
        self.screen = screen
        curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        curses.mouseinterval(0)
        curses.curs_set(0)
        self.get_size()
        curses.use_default_colors()
        curses.init_pair(1, int(SETTINGS['color_title']), -1)
        curses.init_pair(2, int(SETTINGS['color_text']), -1)
        curses.init_pair(3, int(SETTINGS['color_status']), -1)
        curses.init_pair(4, int(SETTINGS['color_buttons']), -1)

        self.quit = False
        self.default_opacity = float(SETTINGS['bg_opacity'])
        self.artist = self.album = self.title = self.file = self.lyrics = self.artistbio = self.guitartabs = None

        self.pager = Pager(self.height - 1, self.width, 0, 0)
        self.statusbar = Statusbar(1, self.width, self.height - 1, 0)

        self.hidden = False
        if SETTINGS['ui_hidden']:
            self.hide()

    def get_size(self):
        self.height, self.width = self.screen.getmaxyx()

    def refresh(self):
        try:
            if SETTINGS['view'] == 'lyrics':
                self.pager.header = wrap(self.artist + ' - ' + self.title, self.width - 2)
                self.pager.text = wrap(self.lyrics or 'No lyrics found', self.width - 2)
            elif SETTINGS['view'] == 'artistbio':
                self.pager.header = wrap(self.artist, self.width - 2)
                self.pager.text = wrapwords(self.artistbio or 'No artist info found', self.width - 2)
            elif SETTINGS['view'] == 'guitartabs':
                self.pager.header = wrap(self.artist + ' - ' + self.title, self.width - 2)
                self.pager.text = wrap(self.guitartabs or 'No guitar tabs found', self.width - 2)
        except TypeError:
            pass

        # calculate position
        lines = len(self.pager.text) + len(self.pager.header) + 1
        if lines <= self.height - 1:
            self.statusbar.pos = 'All'
        elif self.pager.view[0] == 0:
            self.statusbar.pos = 'Top'
        elif lines <= self.pager.view[1]:
            self.statusbar.pos = 'Bot'
        else:
            self.statusbar.pos = str(int((100 / float(lines - self.height)) * self.pager.view[0] - 1)) + '%'

        if SETTINGS['autoscroll']:
            self.statusbar.pos += ' (%ss)' % SETTINGS['autoscroll_time']

        self.pager.refresh()
        self.statusbar.refresh()

    def toggle_views(self):
        if not self.hidden:
            self.pager.scroll('top')

            views = ['lyrics', 'artistbio', 'guitartabs']
            i = views.index(SETTINGS['view']) + 1
            if i >= len(views):
                i = 0
            SETTINGS['view'] = views[i]

            self.refresh()

    def toggle_bg(self):
        if SETTINGS['bg']:
            SETTINGS['bg_type'] = 'cover' if SETTINGS['bg_type'] == 'backdrops' else 'backdrops'
            metadata_get(SETTINGS['bg_type'], self.file, self.artist, self.album, self.title, SETTINGS['lang'])

    def autoscroll(self):
        while True:
            sleep(SETTINGS['autoscroll_time'])
            if SETTINGS['autoscroll']:
                self.pager.scroll(1)
                self.refresh()

    def hide(self):
        if SETTINGS['bg']:
            if not self.hidden:
                SETTINGS['bg_opacity'] = 1
                self.pager.hide()
                self.statusbar.hide()
                self.hidden = True
            else:
                SETTINGS['bg_opacity'] = self.default_opacity
                self.pager.show()
                self.statusbar.show()
                self.hidden = False
            if self.artist or self.album or self.title:
                metadata_get(SETTINGS['bg_type'], self.file, self.artist, self.album, self.title, SETTINGS['lang'])
            else:
                bg_unset()

    def control(self):
        commands = {
            ord(SETTINGS['key_play']): 'play',
            ord(SETTINGS['key_pause']): 'pause',
            ord(SETTINGS['key_next']): 'next',
            ord(SETTINGS['key_prev']): 'prev',
            ord(SETTINGS['key_stop']): 'stop',
            ord(SETTINGS['key_volup']): 'volup',
            ord(SETTINGS['key_voldn']): 'voldn',
        }

        while True:
            key = self.screen.getch()

            x = y = bstate = None
            if key == curses.KEY_MOUSE:
                id, x, y, z, bstate = curses.getmouse()

            if key == ord(SETTINGS['key_quit']):
                self.quit = True

            elif key == curses.KEY_RESIZE:
                self.get_size()

                self.pager.win.resize(self.height - 1, self.width)
                self.pager.view[1] = self.pager.view[0] + self.height - 1

                self.statusbar.win.resize(1, self.width)
                self.statusbar.win.mvwin(self.height - 1, 0)

            elif bstate == curses.BUTTON1_PRESSED:
                if y == self.height - 1:
                    if 1 <= x <= 2:
                        player.command('prev')
                    elif 5 <= x <= 6:
                        player.command('play')
                    elif 9 <= x <= 10:
                        player.command('pause')
                    elif 13 <= x <= 14:
                        player.command('next')
                    elif self.width - len(SETTINGS['view']) - 14 <= x and x < self.width - 14:
                        self.toggle_views()

            elif key == ord(SETTINGS['key_toggle']):
                self.toggle_views()

            elif key == ord(SETTINGS['key_bg_toggle']):
                self.toggle_bg()

            elif key == ord(SETTINGS['key_ui_hide']):
                self.hide()

            elif key in commands:
                player.command(commands[key])

            elif key == curses.KEY_DOWN or key == ord('j'):
                self.pager.scroll(1)
            elif key == curses.KEY_UP or key == ord('k'):
                self.pager.scroll(-1)
            elif bstate == curses.BUTTON2_PRESSED:
                for _ in range(0, 3):
                    self.pager.scroll(1)
            elif bstate == curses.BUTTON4_PRESSED:
                for _ in range(0, 3):
                    self.pager.scroll(-1)
            elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                self.pager.scroll('npage')
            elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                self.pager.scroll('ppage')
            elif key == curses.KEY_END or key == ord('G'):
                self.pager.scroll('bot')
            elif key == curses.KEY_HOME or key == ord('g'):
                self.pager.scroll('top')

            elif key == ord(SETTINGS['key_autoscroll_toggle']):
                SETTINGS['autoscroll'] = True if not SETTINGS['autoscroll'] else False
            elif key == ord(SETTINGS['key_autoscroll_faster']):
                SETTINGS['autoscroll_time'] += SETTINGS['autoscroll_step']
            elif key == ord(SETTINGS['key_autoscroll_slower']):
                SETTINGS['autoscroll_time'] -= SETTINGS['autoscroll_step']
                if SETTINGS['autoscroll_time'] <= 1:
                    SETTINGS['autoscroll_time'] = 1

            self.refresh()


def main(stdscr):
    if 'rxvt' not in os.environ['TERM']:
        SETTINGS['bg'] = False

    ui = Ui(stdscr)

    ui_control = LoggingThread(target=ui.control)
    ui_control.daemon = True
    ui_control.start()

    auto_scroll = LoggingThread(target=ui.autoscroll)
    auto_scroll.daemon = True
    auto_scroll.start()

    lock = Lock()

    while True:
        player.status()

        if ui.quit or not player.running:
            cleanup()
            sys.exit(0 if player.running else 1)

        if player.playing:
            if player.artist != ui.artist or player.album != ui.album or player.title != ui.title:
                if args.debug:
                    logging.info('current song => artist: "%s" title: "%s" album: "%s" file: "%s"' %
                                 (player.artist, player.title, player.album, player.file))
                needsupdate = ['lyrics', 'guitartabs']
                if player.artist != ui.artist or player.album != ui.album:
                    needsupdate.insert(1, 'artistbio')
                    if SETTINGS['bg'] and (SETTINGS['bg_type'] == 'backdrops'
                                           or (SETTINGS['bg_type'] == 'cover' and player.album != ui.album)):
                        needsupdate.insert(0, SETTINGS['bg_type'])
                elif ui.artistbio == 'Searching artist info...':
                        needsupdate.insert(1, 'artistbio')
                if SETTINGS['view'] in needsupdate:
                    needsupdate.insert(1 if SETTINGS['bg_type'] in needsupdate else 0,
                                       needsupdate.pop(needsupdate.index(SETTINGS['view'])))

                lock.acquire()
                try:
                    ui.artist = player.artist
                    ui.album = player.album
                    ui.title = player.title
                    ui.file = player.file
                    if 'lyrics' in needsupdate:
                        ui.lyrics = 'Searching lyrics...'
                    if 'artistbio' in needsupdate:
                        ui.artistbio = 'Searching artist info...'
                    if 'guitartabs' in needsupdate:
                        ui.guitartabs = 'Searching guitar tab...'
                    ui.pager.scroll('top')
                    ui.refresh()
                finally:
                    lock.release()

                worker = LoggingThread(target=get_and_update,
                                       args=(player.artist, player.album, player.title, player.file, needsupdate, ui, lock))
                worker.daemon = True
                worker.start()
        else:
            if SETTINGS['bg']:
                bg_unset()
            ui.artist = player.artist
            ui.album = player.album
            ui.title = player.title
            ui.file = player.file
            ui.lyrics = 'Not playing'
            ui.artistbio = 'Not playing'
            ui.guitartabs = 'Not playing'
            ui.refresh()

        sleep(1)


if __name__ == '__main__':
    args = parse_args()

    if args.config_file:
        if os.path.exists(args.config_file):
            SETTINGS.update(parse_config(args.config_file))
        else:
            sys.exit('File not found: %s' % args.config_file)
    else:
        SETTINGS.update(parse_config(CFG_HOME + '/lyvi/lyvi.conf'))

    if args.debug:
        logging.basicConfig(filename='lyvi.log', level=logging.DEBUG)
        logging.info('Lyvi %s (libglyr %s), executed with Python %s' % (VERSION, GLYR_VERSION, sys.version.split()[0]))
        logging.info('settings => %s', SETTINGS)

    if args.version:
        print('Lyvi %s (libglyr %s)' % (VERSION, GLYR_VERSION))
        sys.exit()

    try:
        player = search_player() or sys.exit('No supported player found.\nYou must launch your player first.')
        if args.debug:
            logging.info('player => %s' % player.__class__.__name__)

        if args.command:
            if args.command in player.ctl['commands']:
                if args.debug:
                    logging.info('sending command => %s' % args.command)
                player.command(args.command)
            else:
                sys.exit('Unknown command: %s' % args.command)
        else:
            curses.wrapper(main)
    except KeyboardInterrupt:
        sys.exit()
    except SystemExit:
        raise
    except Exception:
        if args.debug:
            logging.exception('Uncaught exception')
        raise
