#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import sys
if sys.version > '3':
    sys.exit('Lyvi doesn\'t work with Python 3.')

import Image
import argparse
import codecs
import curses
import imghdr
import logging
import os
import socket
import subprocess
from getpass import getuser
from shutil import copy2
from textwrap import wrap as wrapwords
from threading import Thread, Lock
from time import sleep
from urllib2 import urlopen

import plyr


VERSION = '1.1.0-git'
GLYR_VERSION = plyr.version().split()[1]
HOME = os.environ['HOME']
CFG_HOME = os.environ['XDG_CONFIG_HOME'] if 'XDG_CONFIG_HOME' in os.environ else HOME + '/.config'
DATA_HOME = os.environ['XDG_DATA_HOME'] if 'XDG_DATA_HOME' in os.environ else HOME + '/.local/share'
SETTINGS = {
    'autoscroll': False,
    'autoscroll_time': 10,
    'autoscroll_step': 1,
    'bg': False,
    'bg_color': '000000',
    'bg_opacity': 0.15,
    'bg_local': False,
    'bg_path_artist': None,
    'bg_path_cover': None,
    'bg_type': 'backdrops',
    'color_buttons': -1,
    'color_status': -1,
    'color_text': -1,
    'color_title': 7,
    'key_autoscroll_faster': 'p',
    'key_autoscroll_slower': 'o',
    'key_autoscroll_toggle': 'i',
    'key_bg_toggle': 's',
    'key_next': 'b',
    'key_pause': 'c',
    'key_play': 'x',
    'key_prev': 'z',
    'key_quit': 'q',
    'key_stop': 'v',
    'key_toggle': 'a',
    'key_ui_hide': 'h',
    'key_voldn': '-',
    'key_volup': '=',
    'lang': 'en',
    'mpd_config_file': HOME + '/.mpdconf',
    'mpd_host': 'localhost',
    'mpd_port': 6600,
    'player': None,
    'save_lyrics': False,
    'save_lyrics_format': '<filename>.lyric',
    'ui_hidden': False,
    'view': 'lyrics',
}


class LoggingThread(Thread):
    def run(self):
        try:
            super(LoggingThread, self).run()
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception:
            if args.debug:
                logging.exception('Uncaught exception')
            raise


def parse_args():
    parser = argparse.ArgumentParser(prog='lyvi')
    parser.add_argument('command', nargs='?', help='send a command to player')
    parser.add_argument('-c', '--config-file', help='path to an alternate config file')
    parser.add_argument('-d', '--debug', help='enable debug mode', action='store_true')
    parser.add_argument('-v', '--version', help='print version information', action='store_true')
    return parser.parse_args()


def parse_config(file):
    settings = {}
    try:
        with open(file, 'r') as file:
            for line in file.read().splitlines():
                if not line.strip().startswith('#') and '=' in line:
                    key, value = [x.strip() for x in line.split('=', 1)]
                    if value == 'True':
                        value = True
                    elif value == 'False':
                        value = False
                    elif key != 'bg_color' and (value.isdigit() or (value.startswith('-') and value[1:].isdigit())):
                        value = int(value)
                    settings[key] = value
                else:
                    continue
    finally:
        return settings


def search_player():
    local = ('localhost', '127.0.0.1')
    players = {
        'cmus': Cmus,
        'shell-fm': Shellfm,
        'pianobar': Pianobar,
        'mocp': Moc,
        'gmusicbrowser': Gmusicbrowser,
        'mplayer': Mplayer,
        'vlc': Vlc,
        'audacious': Audacious,
        'deadbeef-main': Deadbeef,
        'qmmp': Qmmp,
        'guayadeque': Guayadeque,
    }

    if SETTINGS['player']:
        if SETTINGS['player'] == 'mpd' and (running('mpd') or SETTINGS['mpd_host'] not in local):
            return Mpd(SETTINGS['mpd_host'], SETTINGS['mpd_port'])
        if running(SETTINGS['player']):
            return players[SETTINGS['player']]()

    for player in players:
        if running(player):
            return players[player]()

    if running('mpd') or SETTINGS['mpd_host'] not in local:
        return Mpd(SETTINGS['mpd_host'], SETTINGS['mpd_port'])


def wrap(text, width):
    wrapped = []
    for line in text.splitlines():
        while len(line) > width:
            wrapped.append(line[:width - 1] + 'â†’'.decode('utf-8'))
            line = line[width - 1:]
        wrapped.append(line)
    return wrapped


def process_socket(command, file):
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.connect(file)
    s.send((command + '\n').encode())
    s.close()


def process_fifo(command, file):
    f = open(file, 'w')
    f.write(command + '\n')
    f.flush()


def get_output(command):
    try:
        return subprocess.check_output(command, shell=True).decode('utf-8').strip()
    except subprocess.CalledProcessError:
        return ''


def running(process):
    return True if process in get_output('ps -C %s' % process) else False


def bg_set(file, opacity):
    # darken/lighten image
    image1 = Image.open(file)
    image2 = image1.point(lambda p: p * opacity)
    image2.save(file)

    # set urxvt background, keep aspect ratio
    os.system('printf "\e]20;%s;100x100+50+50:op=keep-aspect\a"' % file)


def bg_unset():
    # Ugly, but I can't find any way to unset urxvt background.
    # So, we will create an image with the same color as terminal bg color and set it as background.
    if not os.path.exists('/tmp/lyvi_blank.png'):
        image = Image.new('RGB', (100, 100), '#' + SETTINGS['bg_color'])
        image.save('/tmp/lyvi_blank.png')

    # set urxvt background, stretch
    os.system('printf "\e]20;/tmp/lyvi_blank.png\a"')


def bg_setlocal():
    replace_strings = {
        '<artist>': player.artist,
        '<artistinitial>': player.artist[0],
        '<album>': player.album,
    }
    bg_path = SETTINGS['bg_path_artist'] if SETTINGS['bg_type'] == 'backdrops' else SETTINGS['bg_path_cover']
    try:
        for string in replace_strings:
            bg_path = bg_path.replace(string, replace_strings[string])
    except:
        return
    imgs = []
    for root, subfolders, files in os.walk(bg_path):
        for file in files:
            if imghdr.what(os.path.abspath(os.path.join(root, file))):
                imgs.append(os.path.abspath(os.path.join(root, file)))
    if imgs:
        tmp_img = '/tmp/lyvi_%s.%s' % (SETTINGS['bg_type'], imgs[0].split('.')[-1])
        copy2(imgs[0], '/tmp')
        os.rename('/tmp/' + imgs[0].split('/')[-1], tmp_img)
        bg_set(tmp_img, float(SETTINGS['bg_opacity']))
    else:
        bg_unset()


def glyr_query(type, artist, album, title, lang):
        cache_dir = DATA_HOME + '/lyvi'
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)

        db = plyr.Database(cache_dir)
        query = plyr.Query(artist=artist, album=album, title=title, get_type=type, database=db, language=lang)
        query.useragent = 'lyvi/%s' % VERSION
        return query.commit()


def metadata_get(type, artist, album, title, lang):
    if ((type == 'lyrics' and (artist == 'N/A' or title == 'N/A'))
            or (type == 'cover' and (artist == 'N/A' or title == 'N/A'))
            or ((type == 'artistbio' or type == SETTINGS['bg_type']) and artist == 'N/A')
            or (type == 'guitartabs' and (artist == 'N/A' or title == 'N/A'))):
        return 'Missing tags'

    if type == SETTINGS['bg_type']:
        try:
            img = glyr_query(type, artist, album, title, lang)[0].data
        except IndexError:
            try:
                img = glyr_query('artistphoto', artist, album, title, lang)[0].data
            except IndexError:
                img = None
        if img:
            with open('/tmp/lyvi_%s.jpg' % SETTINGS['bg_type'], 'wb') as file:
                file.write(img)
            bg_set('/tmp/lyvi_%s.jpg' % SETTINGS['bg_type'], float(SETTINGS['bg_opacity']))
        else:
            bg_unset()

    else:
        try:
            return glyr_query(type, artist, album, title, lang)[0].data.decode('utf-8')
        except IndexError:
            return


def get_and_update(artist, album, title, file, needsupdate, ui, lock):
    if SETTINGS['bg_type'] in needsupdate:
        if SETTINGS['bg_local']:
            bg_setlocal()
            needsupdate.remove(SETTINGS['bg_type'])

    for type in needsupdate:
        m = metadata_get(type, artist, album, title, SETTINGS['lang'])

        lock.acquire()
        try:
            if ui.artist + ui.title == artist + title:
                setattr(ui, type, m)
                ui.refresh()
        finally:
            lock.release()

        # Optionally save lyric to a file
        if SETTINGS['save_lyrics'] and file and type == 'lyrics' and m and m != 'Missing tags':
            path, filename = file.rsplit('/', 1)
            replace_strings = {
                '<filename>': filename.rsplit('.', 1)[0],
                '<title>': title,
                '<artist>': artist,
            }
            lyric_filename = SETTINGS['save_lyrics_format']
            for string in replace_strings:
                lyric_filename = lyric_filename.replace(string, replace_strings[string])
            with codecs.open('%s/%s' % (path, lyric_filename), 'w', 'utf-8') as file:
                file.write(m)


class Player:
    def status(self):
        self.file = None
        if not self.run:
            self.running = True
        elif self.run['type'] == 'file':
            self.running = os.path.exists(self.run['name'])
        elif self.run['type'] == 'process':
            self.running = running(self.run['name'])

        if self.np['type'] == 'np_file' or self.np['type'] == 'np_command':
            if self.np['type'] == 'np_file':
                try:
                    with codecs.open(self.np['name'], 'r', 'utf-8') as file:
                        s = file.read()
                except IOError:
                    s = ''
            elif self.np['type'] == 'np_command':
                s = get_output(self.np['name'])

            self.playing = True
            s = s.strip().split('\\')
            if len(s) < 2:
                self.playing = False
            else:
                self.artist = s[0]
                self.title = s[1]
                self.album = s[2]
                if len(s) > 3:
                    self.file = s[3]

                    # mpd workaround
                    if self.__class__.__name__ == 'Mpd':
                        f = open(SETTINGS['mpd_config_file'])
                        for line in f.read().splitlines():
                            if 'music_directory' in line and '#' not in line.split('music_directory')[0]:
                                music_dir = line.split('"')[1]
                        if not music_dir.endswith('/'):
                            music_dir += '/'
                        self.file = music_dir + self.file

                    # deadbeef workaround
                    if self.title == self.file.rsplit('.', 1)[0]:
                        self.title = 'N/A'

        else:
            if self.np['type'] == 'command':
                s = get_output(self.np['name'])
            elif self.np['type'] == 'log':
                with open(self.np['name']) as file:
                    s = f.read().split(self.np['str']['beg'])[-1]
            elif self.np['type'] == 'url':
                while True:
                    try:
                        p = urlopen(self.np['name'])
                        break
                    except:
                        continue
                s = p.read().decode()
                p.close()

            if self.np['str']['stopped'] in s:
                self.playing = False
            else:
                self.playing = True
                self.artist = s.split(self.np['str']['artist_beg'])[1].split(self.np['str']['artist_end'])[0]\
                    if self.np['str']['artist_beg'] in s else 'N/A'
                self.album = s.split(self.np['str']['album_beg'])[1].split(self.np['str']['album_end'])[0]\
                    if self.np['str']['album_beg'] in s else 'N/A'
                self.title = s.split(self.np['str']['title_beg'])[1].split(self.np['str']['title_end'])[0]\
                    if self.np['str']['title_beg'] in s else 'N/A'

                if self.np['str']['file_beg'] in s:
                    self.file = s.split(self.np['str']['file_beg'])[1].split(self.np['str']['file_end'])[0]

                    # guayadeque workaround
                    if self.__class__.__name__ == 'Guayadeque':
                        if self.file.startswith('file://'):
                            self.file = self.file.split('file://')[1]
                        else:
                            self.file = None

        if not self.playing:
            self.artist = 'N/A'
            self.album = 'N/A'
            self.title = 'N/A'
        else:
            missing_tag = ['', 'Unknown artist']
            if self.artist in missing_tag:
                self.artist = 'N/A'
            if self.title in missing_tag:
                self.title = 'N/A'

    def command(self, command):
        if command in self.ctl['commands']:
            if self.ctl['type'] == 'socket':
                process_socket(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'fifo':
                process_fifo(self.ctl['commands'][command], self.ctl['name'])
            elif self.ctl['type'] == 'command':
                os.system(self.ctl['commands'][command])


class Cmus(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.cmus/socket',
        }
        self.np = {
            'type': 'command',
            'name': 'cmus-remote -Q',
            'str': {
                'artist_beg': 'tag artist ',
                'artist_end': '\n',
                'album_beg': 'tag album ',
                'album_end': '\n',
                'title_beg': 'tag title ',
                'title_end': '\n',
                'file_beg': 'file ',
                'file_end': '\n',
                'stopped': 'status stopped',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'cmus-remote -p',
                'pause': 'cmus-remote -u',
                'next': 'cmus-remote -n',
                'prev': 'cmus-remote -r',
                'stop': 'cmus-remote -s',
                'volup': 'cmus-remote -v +5%',
                'voldn': 'cmus-remote -v -5%',
            },
        }


class Shellfm(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.shell-fm/session',
        }
        self.np = {
            'type': 'np_file',
            'name': HOME + '/.shell-fm/nowplaying',
        }
        self.ctl = {
            'type': 'socket',
            'name': HOME + '/.shell-fm/socket',
            'commands': {
                'pause': 'pause',
                'next': 'skip',
                'stop': 'stop',
                'volup': 'volume +5',
                'voldn': 'volume -5',
            },
        }


class Pianobar(Player):
    def __init__(self):
        config_dir = CFG_HOME + '/pianobar/'

        # set default keys
        settings = {
            'key_pause': 'p',
            'key_next': 'n',
            'key_stop': 'q',
            'key_volup': ')',
            'key_voldn': '(',
        }
        settings.update(parse_config(config_dir + 'config'))

        self.run = {
            'type': 'process',
            'name': 'pianobar',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'fifo',
            'name': config_dir + 'ctl',
            'commands': {
                'play': settings['key_pause'],
                'pause': settings['key_pause'],
                'next': settings['key_next'],
                'stop': settings['key_stop'],
                'volup': settings['key_volup'],
                'voldn': settings['key_voldn'],
            },
        }


class Mpd(Player):
    def __init__(self, host, port):
        local = ('localhost', '127.0.0.1')
        mpc = 'mpc -h %s -p %s' % (host, port)

        self.run = {
            'type': 'process',
            'name': 'mpd',
        } if host in local else None
        self.np = {
            'type': 'np_command',
            'name': mpc + ' current -f "%artist%\\%title%\\%album%\\%file%"' if host in local
            else mpc + ' current -f "%artist%\\%title%\\%album%"',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': '%s play > /dev/null' % mpc,
                'pause': '%s pause > /dev/null' % mpc,
                'next': '%s next > /dev/null' % mpc,
                'prev': '%s prev > /dev/null' % mpc,
                'stop': '%s stop > /dev/null' % mpc,
                'volup': '%s volume +5 > /dev/null' % mpc,
                'voldn': '%s volume -5 > /dev/null' % mpc,
            },
        }


class Moc(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': HOME + '/.moc/pid',
        }
        self.np = {
            'type': 'command',
            'name': 'mocp -i 2>/dev/null',
            'str': {
                'artist_beg': 'Artist: ',
                'artist_end': '\n',
                'album_beg': 'Album: ',
                'album_end': '\n',
                'title_beg': 'SongTitle: ',
                'title_end': '\n',
                'file_beg': 'File: ',
                'file_end': '\n',
                'stopped': 'State: STOP',
            }
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'mocp -U 2> /dev/null',
                'pause': 'mocp -P 2> /dev/null',
                'next': 'mocp -f 2> /dev/null',
                'prev': 'mocp -r 2> /dev/null',
                'stop': 'mocp -s 2> /dev/null',
                'volup': 'mocp --volume +5 2> /dev/null',
                'voldn': 'mocp --volume -5 2> /dev/null',
            },
        }


class Mplayer(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'mplayer',
        }
        self.np = {
            'type': 'log',
            'name': HOME + '/.mplayer/log',
            'str': {
                'beg': 'AUDIO_ID',
                'artist_beg': 'VALUE1=',
                'artist_end': '\n',
                'album_beg': 'VALUE3=',
                'album_end': '\n',
                'title_beg': 'VALUE0=',
                'title_end': '\n',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'fifo',
            'name': HOME + '/.mplayer/fifo',
            'commands': {
                'play': 'pause',
                'pause': 'pause',
                'next': 'pt_step 1',
                'prev': 'pt_step -1',
                'stop': 'stop',
                'volup': 'volume +1',
                'voldn': 'volume -1',
            },
        }


class Vlc(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': '/tmp/vlc.sock',
        }
        self.np = {
            'type': 'url',
            'name': 'http://localhost:8080/requests/status.xml',
            'str': {
                'artist_beg': 'name=\'artist\'>',
                'artist_end': '</info>',
                'album_beg': 'name=\'album\'>',
                'album_end': '</info>',
                'title_beg': 'name=\'title\'>',
                'title_end': '</info>',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '<state>stopped</state>',
            },
        }
        self.ctl = {
            'type': 'socket',
            'name': '/tmp/vlc.sock',
            'commands': {
                'play': 'pause',
                'pause': 'pause',
                'next': 'next',
                'prev': 'prev',
                'stop': 'stop',
                'volup': 'volup 1',
                'voldn': 'voldown 1',
            },
        }


class Audacious(Player):
    def __init__(self):
        config_dir = CFG_HOME + '/audacious/'

        self.run = {
            'type': 'file',
            'name': config_dir + 'lock',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'audtool --playback-playpause',
                'pause': 'audtool --playback-playpause',
                'next': 'audtool --playlist-advance',
                'prev': 'audtool --playlist-reverse',
                'stop': 'audtool --playback-stop',
                'volup': 'audtool --set-volume +5',
                'voldn': 'audtool --set-volume -5',
            },
        }


class Deadbeef(Player):
    def __init__(self):
        self.run = {
            'type': 'process',
            'name': 'deadbeef-main',
        }
        self.np = {
            'type': 'np_command',
            'name': 'deadbeef --nowplaying "%a%\\%t%\\%b%\\%f%" 2>/dev/null',
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'deadbeef --play 2> /dev/null',
                'pause': 'deadbeef --toggle-pause 2> /dev/null',
                'next': 'deadbeef --next 2> /dev/null',
                'prev': 'deadbeef --prev 2> /dev/null',
                'stop': 'deadbeef --stop 2> /dev/null',
            },
        }


class Qmmp(Player):
    def __init__(self):
        self.run = {
            'type': 'file',
            'name': '/tmp/qmmp.sock.1000',
        }
        self.np = {
            'type': 'command',
            'name': 'qmmp --status --no-start',
            'str': {
                'artist_beg': 'ARTIST = ',
                'artist_end': '\n',
                'album_beg': 'ALBUM = ',
                'album_end': '\n',
                'title_beg': 'TITLE = ',
                'title_end': '\n',
                'file_beg': '||||',
                'file_end': '||||',
                'stopped': '[stopped]',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': 'qmmp -t',
                'pause': 'qmmp -t',
                'next': 'qmmp --next',
                'prev': 'qmmp --previous',
                'stop': 'qmmp -s',
                'volup': 'qmmp --volume-inc',
                'voldn': 'qmmp --volume-dec',
            },
        }


class Guayadeque(Player):
    def __init__(self):
        cmd_base = 'dbus-send --print-reply --type=method_call --dest=org.mpris.guayadeque /Player\
                    org.freedesktop.MediaPlayer.'
        str_base = '"\n         variant             string "'

        self.run = {
            'type': 'file',
            'name': '%s/.guayadeque/.guayadeque-%s' (HOME, getuser()),
        }
        self.np = {
            'type': 'command',
            'name': cmd_base + 'GetMetadata',
            'str': {
                'artist_beg': 'artist' + str_base,
                'artist_end': '"\n',
                'album_beg': 'album' + str_base,
                'album_end': '"\n',
                'title_beg': 'title' + str_base,
                'title_end': '"\n',
                'file_beg': 'location' + str_base,
                'file_end': '"\n',
                'stopped': '||||',
            },
        }
        self.ctl = {
            'type': 'command',
            'commands': {
                'play': cmd_base + 'Play &> /dev/null',
                'pause': cmd_base + 'Play &> /dev/null',
                'next': cmd_base + 'Next &> /dev/null',
                'prev': cmd_base + 'Prev &> /dev/null',
                'stop': cmd_base + 'Stop &> /dev/null',
            },
        }


class Gmusicbrowser(Player):
    def __init__(self):
        config_dir = CFG_HOME + '/gmusicbrowser/'

        self.run = {
            'type': 'file',
            'name': config_dir + 'gmusicbrowser.fifo',
        }
        self.np = {
            'type': 'np_file',
            'name': config_dir + 'nowplaying',
        }
        self.ctl = {
            'type': 'fifo',
            'name': self.run['name'],
            'commands': {
                'play': 'PlayPause',
                'pause': 'PlayPause',
                'next': 'NextSong',
                'prev': 'PrevSong',
                'stop': 'Stop',
            },
        }


class Window:
    def __init__(self, lines, cols, y, x):
        self.win = curses.newwin(lines, cols, y, x)
        self.hidden = False

    def get_size(self):
        self.height, self.width = self.win.getmaxyx()

    def show(self):
        self.hidden = False

    def hide(self):
        self.hidden = True

    def refresh(self):
        self.win.refresh()


class Pager(Window):
    def __init__(self, lines, cols, y, x):
        Window.__init__(self, lines, cols, y, x)
        self.get_size()
        self.view = [0, self.height]
        self.header = []
        self.text = []

    def scroll(self, increment):
        if not self.hidden:
            self.get_size()
            if increment == 'top':
                self.view[0] = 0
                self.view[1] = self.height
            elif increment == 'bot':
                self.view[1] = len(self.text) + len(self.header) + 1
                self.view[0] = self.view[1] - self.height if self.view[1] - self.height >= 0 else 0
            elif increment == 'npage':
                if self.view[0] + self.height < len(self.text) + len(self.header) + 1:
                    self.view[0] += self.height
                    self.view[1] += self.height
            elif increment == 'ppage':
                if self.view[0] - self.height < 0:
                    self.view[0] = 0
                    self.view[1] = self.height
                else:
                    self.view[0] -= self.height
                    self.view[1] -= self.height
            elif ((increment < 0 and self.view[0] + increment >= 0)
                    or (increment > 0 and self.view[1] < len(self.text) + len(self.header) + 1)):
                self.view[0] += increment
                self.view[1] += increment

    def refresh(self):
        self.win.erase()

        if not self.hidden:
            text = list(self.text)
            for i in range(0, len(self.header)):
                text.insert(i, self.header[i])
            text.insert(len(self.header), '')

            y = 0
            for i in range(self.view[0], self.view[1]):
                if i < len(self.header):
                    color = curses.color_pair(1) | curses.A_BOLD
                else:
                    color = curses.color_pair(2)
                try:
                    self.win.addstr(y, 1, text[i].encode('utf-8'), color)
                except IndexError:
                    break
                y += 1

        Window.refresh(self)


class Statusbar(Window):
    def __init__(self, lines, cols, y, x):
        Window.__init__(self, lines, cols, y, x)
        self.pos = 'Top'

    def refresh(self):
        self.win.erase()

        if not self.hidden:
            self.get_size()
            self.win.addstr(0, 1, '|<  >>  ||  >|', curses.color_pair(4))
            self.win.addstr(0, self.width - len(SETTINGS['view']) - 14, SETTINGS['view'], curses.color_pair(3))
            self.win.addstr(0, self.width - len(self.pos) - 1, self.pos, curses.color_pair(3))

        Window.refresh(self)


class Ui:
    def __init__(self, screen):
        self.screen = screen
        curses.mousemask(curses.ALL_MOUSE_EVENTS | curses.REPORT_MOUSE_POSITION)
        curses.mouseinterval(0)
        curses.curs_set(0)
        self.get_size()
        curses.use_default_colors()
        curses.init_pair(1, int(SETTINGS['color_title']), -1)
        curses.init_pair(2, int(SETTINGS['color_text']), -1)
        curses.init_pair(3, int(SETTINGS['color_status']), -1)
        curses.init_pair(4, int(SETTINGS['color_buttons']), -1)

        self.quit = False
        self.default_opacity = float(SETTINGS['bg_opacity'])
        self.artist = self.album = self.title = self.lyrics = self.artistbio = self.guitartabs = None

        self.pager = Pager(self.height - 1, self.width, 0, 0)
        self.statusbar = Statusbar(1, self.width, self.height - 1, 0)

        self.hidden = False
        if SETTINGS['ui_hidden']:
            self.hide()

    def get_size(self):
        self.height, self.width = self.screen.getmaxyx()

    def refresh(self):
        try:
            if SETTINGS['view'] == 'lyrics':
                self.pager.header = wrap(self.artist + ' - ' + self.title, self.width - 2)
                self.pager.text = wrap(self.lyrics or 'No lyrics found', self.width - 2)
            elif SETTINGS['view'] == 'artistbio':
                self.pager.header = wrap(self.artist, self.width - 2)
                self.pager.text = wrapwords(self.artistbio or 'No artist info found', self.width - 2)
            elif SETTINGS['view'] == 'guitartabs':
                self.pager.header = wrap(self.artist + ' - ' + self.title, self.width - 2)
                self.pager.text = wrap(self.guitartabs or 'No guitar tabs found', self.width - 2)
        except TypeError:
            pass

        # calculate position
        lines = len(self.pager.text) + len(self.pager.header) + 1
        if lines <= self.height - 1:
            self.statusbar.pos = 'All'
        elif self.pager.view[0] == 0:
            self.statusbar.pos = 'Top'
        elif lines <= self.pager.view[1]:
            self.statusbar.pos = 'Bot'
        else:
            self.statusbar.pos = str(int((100 / float(lines - self.height)) * self.pager.view[0] - 1)) + '%'

        if SETTINGS['autoscroll']:
            self.statusbar.pos += ' (%ss)' % SETTINGS['autoscroll_time']

        self.pager.refresh()
        self.statusbar.refresh()

    def toggle_views(self):
        if not self.hidden:
            self.pager.scroll('top')

            views = ['lyrics', 'artistbio', 'guitartabs']
            i = views.index(SETTINGS['view']) + 1
            if i >= len(views):
                i = 0
            SETTINGS['view'] = views[i]

            self.refresh()

    def toggle_bg(self):
        if SETTINGS['bg']:
            SETTINGS['bg_type'] = 'cover' if SETTINGS['bg_type'] == 'backdrops' else 'backdrops'
            if SETTINGS['bg_local']:
                bg_setlocal()
            else:
                metadata_get(SETTINGS['bg_type'], self.artist, self.album, self.title, SETTINGS['lang'])

    def autoscroll(self):
        while True:
            sleep(SETTINGS['autoscroll_time'])
            if SETTINGS['autoscroll']:
                self.pager.scroll(1)
                self.refresh()

    def hide(self):
        if SETTINGS['bg']:
            if not self.hidden:
                SETTINGS['bg_opacity'] = 1
                self.pager.hide()
                self.statusbar.hide()
                self.hidden = True
            else:
                SETTINGS['bg_opacity'] = self.default_opacity
                self.pager.show()
                self.statusbar.show()
                self.hidden = False
            if self.artist or self.album or self.title:
                if SETTINGS['bg_local']:
                    bg_setlocal()
                else:
                    metadata_get(SETTINGS['bg_type'], self.artist, self.album, self.title, SETTINGS['lang'])
            else:
                bg_unset()

    def control(self):
        commands = {
            ord(SETTINGS['key_play']): 'play',
            ord(SETTINGS['key_pause']): 'pause',
            ord(SETTINGS['key_next']): 'next',
            ord(SETTINGS['key_prev']): 'prev',
            ord(SETTINGS['key_stop']): 'stop',
            ord(SETTINGS['key_volup']): 'volup',
            ord(SETTINGS['key_voldn']): 'voldn',
        }

        while True:
            key = self.screen.getch()

            x = y = bstate = None
            if key == curses.KEY_MOUSE:
                id, x, y, z, bstate = curses.getmouse()

            if key == ord(SETTINGS['key_quit']):
                self.quit = True

            elif key == curses.KEY_RESIZE:
                self.get_size()

                self.pager.win.resize(self.height - 1, self.width)
                self.pager.view[1] = self.pager.view[0] + self.height - 1

                self.statusbar.win.resize(1, self.width)
                self.statusbar.win.mvwin(self.height - 1, 0)

            elif bstate == curses.BUTTON1_PRESSED:
                if y == self.height - 1:
                    if 1 <= x <= 2:
                        player.command('prev')
                    elif 5 <= x <= 6:
                        player.command('play')
                    elif 9 <= x <= 10:
                        player.command('pause')
                    elif 13 <= x <= 14:
                        player.command('next')
                    elif self.width - len(SETTINGS['view']) - 14 <= x and x < self.width - 14:
                        self.toggle_views()

            elif key == ord(SETTINGS['key_toggle']):
                self.toggle_views()

            elif key == ord(SETTINGS['key_bg_toggle']):
                self.toggle_bg()

            elif key == ord(SETTINGS['key_ui_hide']):
                self.hide()

            elif key in commands:
                player.command(commands[key])

            elif key == curses.KEY_DOWN or key == ord('j'):
                self.pager.scroll(1)
            elif key == curses.KEY_UP or key == ord('k'):
                self.pager.scroll(-1)
            elif bstate == curses.BUTTON2_PRESSED:
                for _ in range(0, 3):
                    self.pager.scroll(1)
            elif bstate == curses.BUTTON4_PRESSED:
                for _ in range(0, 3):
                    self.pager.scroll(-1)
            elif key == curses.KEY_NPAGE or key == curses.KEY_RIGHT:
                self.pager.scroll('npage')
            elif key == curses.KEY_PPAGE or key == curses.KEY_LEFT:
                self.pager.scroll('ppage')
            elif key == curses.KEY_END or key == ord('G'):
                self.pager.scroll('bot')
            elif key == curses.KEY_HOME or key == ord('g'):
                self.pager.scroll('top')

            elif key == ord(SETTINGS['key_autoscroll_toggle']):
                SETTINGS['autoscroll'] = True if not SETTINGS['autoscroll'] else False
            elif key == ord(SETTINGS['key_autoscroll_faster']):
                SETTINGS['autoscroll_time'] += SETTINGS['autoscroll_step']
            elif key == ord(SETTINGS['key_autoscroll_slower']):
                SETTINGS['autoscroll_time'] -= SETTINGS['autoscroll_step']
                if SETTINGS['autoscroll_time'] <= 1:
                    SETTINGS['autoscroll_time'] = 1

            self.refresh()


def main(stdscr):
    ui = Ui(stdscr)

    ui_control = LoggingThread(target=ui.control)
    ui_control.daemon = True
    ui_control.start()

    auto_scroll = LoggingThread(target=ui.autoscroll)
    auto_scroll.daemon = True
    auto_scroll.start()

    lock = Lock()

    while True:
        player.status()

        if ui.quit or not player.running:
            break

        if player.playing:
            if player.artist != ui.artist or player.album != ui.album or player.title != ui.title:
                needsupdate = ['lyrics', 'guitartabs']
                if player.artist != ui.artist or player.album != ui.album:
                    needsupdate.insert(1, 'artistbio')
                    if SETTINGS['bg'] and (SETTINGS['bg_type'] == 'backdrops'
                                           or (SETTINGS['bg_type'] == 'cover' and player.album != ui.album)):
                        needsupdate.insert(0, SETTINGS['bg_type'])
                elif ui.artistbio == 'Searching artist info...':
                        needsupdate.insert(1, 'artistbio')
                if SETTINGS['view'] in needsupdate:
                    needsupdate.insert(1 if SETTINGS['bg_type'] in needsupdate else 0,
                                       needsupdate.pop(needsupdate.index(SETTINGS['view'])))

                lock.acquire()
                try:
                    ui.artist = player.artist
                    ui.album = player.album
                    ui.title = player.title
                    if 'lyrics' in needsupdate:
                        ui.lyrics = 'Searching lyrics...'
                    if 'artistbio' in needsupdate:
                        ui.artistbio = 'Searching artist info...'
                    if 'guitartabs' in needsupdate:
                        ui.guitartabs = 'Searching guitar tab...'
                    ui.pager.scroll('top')
                    ui.refresh()
                finally:
                    lock.release()

                worker = LoggingThread(target=get_and_update,
                                       args=(player.artist, player.album, player.title, player.file, needsupdate, ui, lock))
                worker.daemon = True
                worker.start()
        else:
            if SETTINGS['bg']:
                bg_unset()
            ui.artist = player.artist
            ui.album = player.album
            ui.title = player.title
            ui.lyrics = 'Not playing'
            ui.artistbio = 'Not playing'
            ui.guitartabs = 'Not playing'
            ui.refresh()

        sleep(1)

    # cleanup
    if SETTINGS['bg']:
        bg_unset()
    if not player.running:
        if os.path.exists(player.np['name']):
            os.remove(player.np['name'])


if __name__ == '__main__':
    args = parse_args()

    if args.config_file:
        if os.path.exists(args.config_file):
            SETTINGS.update(parse_config(args.config_file))
        else:
            sys.exit('File not found: %s' % args.config_file)
    else:
        SETTINGS.update(parse_config(CFG_HOME + '/lyvi/rc'))

    if args.debug:
        logging.basicConfig(filename='lyvi.log', level=logging.DEBUG)
        logging.info('Lyvi %s (libglyr %s), executed with Python %s' % (VERSION, GLYR_VERSION, sys.version.split()[0]))

    if args.version:
        print('Lyvi %s (libglyr %s)' % (VERSION, GLYR_VERSION))
        sys.exit()

    try:
        player = search_player() or sys.exit('No supported player found.\nYou must launch your player first.')

        if args.command:
            if args.command in player.ctl['commands']:
                player.command(args.command)
            else:
                sys.exit('Unknown command: %s' % args.command)
        else:
            curses.wrapper(main)
    except (KeyboardInterrupt, SystemExit):
        raise
    except Exception:
        if args.debug:
            logging.exception('Uncaught exception')
        raise
